name: Backend CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
    paths:
      - "backend/**"
  pull_request:
    branches:
      - main
      - develop
    paths:
      - "backend/**"
  workflow_dispatch:

env:
  NODE_VERSION: "18"
  IMAGE_NAME: hrms-backend
  REGISTRY: ghcr.io
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Testing Job
  test:
    name: Unit & Integration Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Start MySQL test database with Docker Compose
        working-directory: ./backend
        run: |
          echo "ğŸš€ Starting MySQL test database..."
          docker compose -f docker-compose.test.yml up -d
          echo "âœ… MySQL container started"

      - name: Wait for MySQL to be ready
        working-directory: ./backend
        run: |
          echo "â³ Waiting for MySQL to be ready..."

          # Wait for container to be running
          echo "Checking container status..."
          for i in {1..30}; do
            CONTAINER_STATUS=$(docker compose -f docker-compose.test.yml ps mysql-test --format json 2>/dev/null | grep -o '"State":"[^"]*"' | cut -d'"' -f4 || echo "")
            if [ "$CONTAINER_STATUS" = "running" ]; then
              echo "âœ… Container is running"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ Container failed to start"
              docker compose -f docker-compose.test.yml ps -a
              docker compose -f docker-compose.test.yml logs mysql-test
              exit 1
            fi
            echo "Waiting for container... ($i/30)"
            sleep 2
          done

          # Wait for MySQL to accept connections (give it time to initialize)
          echo "Waiting for MySQL to initialize and accept connections..."
          echo "This may take 30-60 seconds for MySQL 8.0..."

          for i in {1..90}; do
            # Try mysqladmin ping inside the container
            if docker compose -f docker-compose.test.yml exec -T mysql-test mysqladmin ping -h localhost -u root -ptestpassword --silent 2>/dev/null; then
              echo "âœ… MySQL is ready and accepting connections!"
              break
            fi
            
            if [ $i -eq 90 ]; then
              echo "âŒ MySQL failed to start after 3 minutes"
              echo "ğŸ“‹ Container logs (last 100 lines):"
              docker compose -f docker-compose.test.yml logs --tail=100 mysql-test
              echo ""
              echo "ğŸ“Š Container status:"
              docker compose -f docker-compose.test.yml ps
              echo ""
              echo "ğŸ” Testing connection manually:"
              docker compose -f docker-compose.test.yml exec -T mysql-test mysqladmin ping -h localhost -u root -ptestpassword || true
              exit 1
            fi
            
            # Show progress every 10 iterations
            if [ $((i % 10)) -eq 0 ]; then
              echo "Still waiting... ($i/90) - MySQL is initializing..."
            fi
            sleep 2
          done

          # Give MySQL additional time to fully initialize
          echo "â³ Waiting additional 5 seconds for MySQL to fully initialize..."
          sleep 5
          echo "âœ… MySQL is ready!"

      - name: Configure MySQL
        working-directory: ./backend
        run: |
          echo "ğŸ”§ Configuring MySQL settings..."

          # Verify connection first
          echo "Verifying MySQL connection..."
          docker compose -f docker-compose.test.yml exec -T mysql-test mysqladmin ping -h localhost -u root -ptestpassword || {
            echo "âŒ Failed to connect to MySQL"
            docker compose -f docker-compose.test.yml logs --tail=20 mysql-test
            exit 1
          }

          # Configure database settings
          echo "Configuring database character set..."
          docker compose -f docker-compose.test.yml exec -T mysql-test mysql -u root -ptestpassword -e "ALTER DATABASE test_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;" 2>&1 || echo "âš ï¸  Character set configuration skipped (may already be set)"

          # Verify database exists
          echo "Verifying test_db database..."
          docker compose -f docker-compose.test.yml exec -T mysql-test mysql -u root -ptestpassword -e "SHOW DATABASES LIKE 'test_db';" | grep test_db || {
            echo "âŒ test_db database not found!"
            exit 1
          }

          echo "âœ… MySQL configuration completed"

      - name: Run database migrations (test)
        working-directory: ./backend
        run: |
          echo "ğŸ”„ Running database migrations..."
          npm run migrate
          if [ $? -ne 0 ]; then
            echo "âŒ Migration failed!"
            exit 1
          fi
          echo "âœ… Migrations completed successfully"
        env:
          NODE_ENV: test
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: testpassword
          DB_NAME: test_db
          DB_PORT: 3307
          DB_DIALECT: mysql

      - name: Verify migration status (test)
        working-directory: ./backend
        run: |
          echo "ğŸ“Š Checking migration status..."
          npm run migrate:status
          if [ $? -ne 0 ]; then
            echo "âŒ Migration status check failed!"
            exit 1
          fi
          echo "âœ… All migrations are up to date"
        env:
          NODE_ENV: test
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: testpassword
          DB_NAME: test_db
          DB_PORT: 3307
          DB_DIALECT: mysql

      - name: Run unit tests
        working-directory: ./backend
        run: npm run test:unit
        env:
          NODE_ENV: test
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: testpassword
          DB_NAME: test_db
          DB_PORT: 3307
          DB_DIALECT: mysql
          JWT_SECRET: test_jwt_secret

      - name: Run integration tests
        working-directory: ./backend
        run: npm run test:integration
        continue-on-error: true
        env:
          NODE_ENV: test
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: testpassword
          DB_NAME: test_db
          DB_PORT: 3307
          DB_DIALECT: mysql
          JWT_SECRET: test_jwt_secret

      - name: Upload test coverage
        uses: codecov/codecov-action@v3
        if: always()
        with:
          files: ./backend/coverage/coverage-final.json
          flags: backend
          name: backend-coverage
        continue-on-error: true

      - name: Stop MySQL test database
        if: always()
        working-directory: ./backend
        run: |
          echo "ğŸ›‘ Stopping MySQL test database..."
          docker compose -f docker-compose.test.yml down -v || true
          echo "âœ… MySQL test database stopped"

  # Linting Job
  lint:
    name: Code Linting
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run ESLint
        working-directory: ./backend
        run: npm run lint

      - name: Check code formatting
        working-directory: ./backend
        run: npm run lint:format
        continue-on-error: true

  # Security Scanning (SCA - Software Composition Analysis)
  security-scan:
    name: Security Vulnerability Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run npm audit
        working-directory: ./backend
        run: npm audit --audit-level=moderate
        continue-on-error: true

      - name: Install Snyk
        continue-on-error: true
        run: npm install -g snyk

      - name: Run Snyk security scan
        continue-on-error: true
        working-directory: ./backend
        run: |
          if [ -n "${{ secrets.SNYK_TOKEN }}" ]; then
            snyk auth ${{ secrets.SNYK_TOKEN }} || true
            snyk test --severity-threshold=high || true
          else
            echo "Snyk token not configured, skipping scan"
          fi
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  # Static Code Analysis (DCA - Dynamic Code Analysis / SAST)
  code-analysis:
    name: Static Code Analysis
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v5.0.0
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          projectBaseDir: ./backend
          args: >
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY || format('{0}_{1}', github.repository_owner, github.event.repository.name) }}
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.sources=.
            -Dsonar.exclusions=**/node_modules/**,**/coverage/**,**/tests/**,**/*.test.js
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v2
        continue-on-error: true
        with:
          languages: javascript
          queries: security-extended,security-and-quality

      - name: Autobuild
        uses: github/codeql-action/autobuild@v2
        continue-on-error: true
        with:
          working-directory: ./backend

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v2
        continue-on-error: true

  # Build Job
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [test, lint, security-scan, code-analysis]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Verify syntax
        working-directory: ./backend
        run: node --check index.js

      - name: Build application
        working-directory: ./backend
        run: npm run build

  # Docker Build Job
  docker-build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify image was pushed
        run: |
          echo "âœ… Image pushed to GHCR:"
          echo "  - ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest"
          echo "  - ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"

  # Deploy to Digital Ocean
  deploy:
    name: Deploy to Digital Ocean
    runs-on: ubuntu-latest
    needs: [docker-build]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    environment:
      name: Production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pull Docker image from GHCR on server
        uses: appleboy/ssh-action@v1.0.0
        env:
          GHCR_TOKEN: ${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            echo "ğŸ“¦ Pulling Docker image from GHCR..."
            REGISTRY="ghcr.io"
            REPO_OWNER_ORIGINAL="${{ github.repository_owner }}"
            REPO_OWNER_LOWER=$(echo "${REPO_OWNER_ORIGINAL}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="hrms-backend"
            IMAGE_FULL_NAME="${REGISTRY}/${REPO_OWNER_LOWER}/${IMAGE_NAME}:latest"
            echo "Image: ${IMAGE_FULL_NAME}"

            # Login to GHCR using Personal Access Token
            # Note: Login username should match GitHub username (case-sensitive for auth)
            if [ -n "${GHCR_TOKEN}" ]; then
              echo "${GHCR_TOKEN}" | docker login ${REGISTRY} -u ${REPO_OWNER_ORIGINAL} --password-stdin
              echo "âœ… Logged in to GHCR"
            else
              echo "âš ï¸  No GHCR token found. Attempting public pull (may fail if package is private)..."
            fi

            # Pull the image
            if docker pull "${IMAGE_FULL_NAME}"; then
              echo "âœ… Image pulled successfully"
            else
              echo "âŒ Failed to pull image. Please ensure:"
              echo "   1. GHCR_PAT secret is set in GitHub Secrets (Production environment)"
              echo "   2. The package permissions allow the token to read"
              echo "   3. The image exists in GHCR: ${IMAGE_FULL_NAME}"
              exit 1
            fi

            # Tag it for local use (docker-compose expects hrms-backend:latest)
            docker tag "${IMAGE_FULL_NAME}" "${IMAGE_NAME}:latest"
            echo "âœ… Docker image pulled and tagged as ${IMAGE_NAME}:latest"
            docker images | grep "${IMAGE_NAME}" || true

      - name: Transfer docker-compose.yml to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          source: "backend/docker-compose.yml"
          target: "/tmp/"
          overwrite: true

      - name: Setup backend directory structure on server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory (with fallbacks)
            BASE_DIR="/opt/hrms"
            if [ ! -d "$BASE_DIR" ]; then
              BASE_DIR="$HOME/hrms"
              if [ ! -d "$BASE_DIR" ]; then
                BASE_DIR="/tmp/hrms"
              fi
              mkdir -p "$BASE_DIR" || {
                echo "âŒ Failed to create directory. Trying with sudo..."
                sudo mkdir -p /opt/hrms || mkdir -p ~/hrms || mkdir -p /tmp/hrms
                BASE_DIR="/opt/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="$HOME/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="/tmp/hrms"
              }
            fi
            # Create backend directory
            mkdir -p "$BASE_DIR/backend" || sudo mkdir -p "$BASE_DIR/backend" || mkdir -p "$HOME/hrms/backend" || mkdir -p "/tmp/hrms/backend"

            # Find and move docker-compose.yml to backend directory
            echo "ğŸ” Searching for docker-compose.yml..."
            DOCKER_COMPOSE_FILE=""

            # Check common locations
            if [ -f "/tmp/docker-compose.yml" ]; then
              DOCKER_COMPOSE_FILE="/tmp/docker-compose.yml"
            elif [ -f "$HOME/docker-compose.yml" ]; then
              DOCKER_COMPOSE_FILE="$HOME/docker-compose.yml"
            else
              # Search in /tmp for any docker-compose.yml
              DOCKER_COMPOSE_FILE=$(find /tmp -name "docker-compose.yml" -type f 2>/dev/null | head -1)
            fi

            if [ -n "$DOCKER_COMPOSE_FILE" ] && [ -f "$DOCKER_COMPOSE_FILE" ]; then
              echo "âœ… Found docker-compose.yml at: $DOCKER_COMPOSE_FILE"
              # Try to move it to the backend directory
              if cp "$DOCKER_COMPOSE_FILE" "$BASE_DIR/backend/docker-compose.yml" 2>/dev/null || \
                 sudo cp "$DOCKER_COMPOSE_FILE" "$BASE_DIR/backend/docker-compose.yml" 2>/dev/null || \
                 cp "$DOCKER_COMPOSE_FILE" "$HOME/hrms/backend/docker-compose.yml" 2>/dev/null || \
                 cp "$DOCKER_COMPOSE_FILE" "/tmp/hrms/backend/docker-compose.yml" 2>/dev/null; then
                echo "âœ… docker-compose.yml copied to $BASE_DIR/backend/"
                # Remove the temporary file
                rm -f "$DOCKER_COMPOSE_FILE" 2>/dev/null || true
              else
                echo "âŒ Failed to copy docker-compose.yml to backend directory"
                exit 1
              fi
            else
              echo "âŒ docker-compose.yml not found in expected locations"
              echo "ğŸ“‹ Contents of /tmp:"
              ls -la /tmp/ | grep -i docker || echo "No docker files found"
              echo "ğŸ“‹ Searching entire /tmp:"
              find /tmp -name "*docker*" -type f 2>/dev/null | head -5 || echo "No docker files found"
              exit 1
            fi

            # Verify the file exists in the backend directory
            if [ ! -f "$BASE_DIR/backend/docker-compose.yml" ]; then
              echo "âŒ docker-compose.yml not found at $BASE_DIR/backend/docker-compose.yml after copy"
              exit 1
            fi
            echo "âœ… Verified docker-compose.yml exists at $BASE_DIR/backend/docker-compose.yml"

      - name: Verify secrets are accessible
        run: |
          echo "ğŸ” Verifying secrets are accessible in workflow..."
          echo "ğŸ“‹ Note: When using 'environment: Production', secrets must be in Production environment"
          echo "ğŸ“‹ If secrets are in repository-level, they won't be accessible"
          echo ""

          # Check if secrets are accessible (they might be in environment or repository-level)
          DB_USER_ACCESSIBLE="${{ secrets.DB_USER }}"
          DB_PASSWORD_ACCESSIBLE="${{ secrets.DB_PASSWORD }}"
          DB_NAME_ACCESSIBLE="${{ secrets.DB_NAME }}"

          if [ -z "$DB_USER_ACCESSIBLE" ]; then
            echo "âŒ ERROR: DB_USER secret is not accessible"
            echo ""
            echo "ğŸ“‹ Possible causes:"
            echo "   1. Secret is in repository-level secrets (not accessible with environment: Production)"
            echo "   2. Secret is not in Production environment"
            echo "   3. Secret value is empty/blank"
            echo "   4. Environment protection rules are blocking access"
            echo ""
            echo "ğŸ“‹ Solution:"
            echo "   Since your workflow uses 'environment: name: Production',"
            echo "   secrets MUST be in: Environments â†’ Production â†’ Environment secrets"
            echo ""
            echo "   Steps to fix:"
            echo "   1. Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
            echo "   2. Click 'Environments' tab (on the right)"
            echo "   3. Click 'Production'"
            echo "   4. Add 'DB_USER' to Environment secrets (not repository secrets)"
            echo "   5. Repeat for DB_PASSWORD, DB_NAME, and all other secrets"
            echo ""
            echo "   OR if you want to use repository-level secrets:"
            echo "   Remove 'environment: name: Production' from the workflow (not recommended)"
            exit 1
          fi

          if [ -z "$DB_PASSWORD_ACCESSIBLE" ]; then
            echo "âŒ ERROR: DB_PASSWORD secret is not accessible"
            echo "   Follow the same steps above to add it to Production environment"
            exit 1
          fi

          if [ -z "$DB_NAME_ACCESSIBLE" ]; then
            echo "âŒ ERROR: DB_NAME secret is not accessible"
            echo "   Follow the same steps above to add it to Production environment"
            exit 1
          fi

          echo "âœ… All required secrets are accessible in workflow"
          echo "âœ… Secrets are being read from: Production environment"

      - name: Create .env file from GitHub Secrets
        run: |
          echo "ğŸ” Creating .env file from GitHub Secrets..."

          # Function to safely write env variable (handles empty values and special characters)
          write_env() {
            local key=$1
            local value=$2
            
            if [ -z "$value" ]; then
              # Empty value - write as-is
              echo "${key}=" >> .env
              return
            fi
            
            # Check if value needs quoting (contains spaces, special chars, or could be interpreted as command)
            needs_quoting=false
            
            # Check for spaces, tabs, newlines
            if [[ "$value" =~ [[:space:]] ]]; then
              needs_quoting=true
            fi
            
            # Check for special characters that need escaping
            if [[ "$value" =~ [\$\\\`\"\'\!\@\#\^\&\*\(\)\[\]\{\}\|\;\<\>\?] ]]; then
              needs_quoting=true
            fi
            
            # Check if starts with dash (could be command option)
            if [[ "$value" =~ ^- ]]; then
              needs_quoting=true
            fi
            
            # Check if value contains characters that could form a valid command when unquoted
            if [ "$needs_quoting" = false ]; then
              if ! [[ "$value" =~ ^[a-zA-Z0-9_\.\-\:\/\+=]+$ ]]; then
                needs_quoting=true
              fi
            fi
            
            if [ "$needs_quoting" = true ]; then
              escaped_value=$(printf '%s' "$value" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/\$/\\$/g' | sed 's/`/\\`/g')
              echo "${key}=\"${escaped_value}\"" >> .env
            else
              echo "${key}=${value}" >> .env
            fi
          }

          # Verify required secrets are accessible
          if [ -z "${{ secrets.DB_USER }}" ]; then
            echo "âŒ ERROR: DB_USER secret is not accessible in Production environment"
            echo "   Go to: https://github.com/${{ github.repository }}/settings/secrets/actions"
            echo "   Click 'Environments' â†’ 'Production' â†’ Add 'DB_USER' secret"
            exit 1
          fi
          if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
            echo "âŒ ERROR: DB_PASSWORD secret is not accessible in Production environment"
            exit 1
          fi
          if [ -z "${{ secrets.DB_NAME }}" ]; then
            echo "âŒ ERROR: DB_NAME secret is not accessible in Production environment"
            exit 1
          fi

          echo "âœ… All required secrets are accessible"
          echo ""

          # Build .env file from GitHub Secrets
          echo "# ==========================================" > .env
          echo "# HRMS Application Environment Variables" >> .env
          echo "# Auto-generated from GitHub Secrets" >> .env
          echo "# ==========================================" >> .env
          echo "" >> .env

          echo "# Application Configuration" >> .env
          write_env "NODE_ENV" "production"
          write_env "PORT" "8000"
          echo "" >> .env

          echo "# Database Configuration" >> .env
          write_env "DB_ROOT_PASSWORD" "${{ secrets.DB_ROOT_PASSWORD }}"
          write_env "DB_NAME" "${{ secrets.DB_NAME }}"
          write_env "DB_USER" "${{ secrets.DB_USER }}"
          write_env "DB_PASSWORD" "${{ secrets.DB_PASSWORD }}"
          write_env "DB_PORT" "${{ secrets.DB_PORT || '3306' }}"
          write_env "DB_DIALECT" "${{ secrets.DB_DIALECT || 'mysql' }}"
          write_env "DB_HOST" "mysql"
          echo "" >> .env

          echo "# Security & Authentication" >> .env
          write_env "JWT_SECRET" "${{ secrets.JWT_SECRET }}"
          echo "" >> .env

          echo "# Email Configuration (SendGrid)" >> .env
          write_env "SENDGRID_API_KEY" "${{ secrets.SENDGRID_API_KEY }}"
          write_env "EMAIL_FROM" "${{ secrets.EMAIL_FROM || 'no-reply@kitor.io' }}"
          write_env "EMAIL_FROM_NAME" "${{ secrets.EMAIL_FROM_NAME || 'Xylobit HRMS' }}"
          echo "" >> .env

          echo "# URL Configuration" >> .env
          write_env "FRONTEND_URL" "${{ secrets.FRONTEND_URL }}"
          write_env "DOMAIN" "${{ secrets.DOMAIN }}"
          write_env "BACKEND_URL" "${{ secrets.BACKEND_URL }}"
          echo "" >> .env

          echo "# Frontend Environment Variables (React - for docker-compose)" >> .env
          write_env "REACT_APP_BACKEND_URL" "${{ secrets.REACT_APP_BACKEND_URL }}"
          write_env "REACT_APP_FRONTEND_URL" "${{ secrets.REACT_APP_FRONTEND_URL }}"
          echo "" >> .env

          echo "# AWS S3 Configuration (File Storage)" >> .env
          write_env "AWS_ACCESS_KEY_ID" "${{ secrets.AWS_ACCESS_KEY_ID }}"
          write_env "AWS_SECRET_ACCESS_KEY" "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          write_env "AWS_REGION" "${{ secrets.AWS_REGION }}"
          write_env "AWS_S3_BUCKET_NAME" "${{ secrets.AWS_S3_BUCKET_NAME }}"

          # Verify file was created
          if [ -f .env ]; then
            echo "âœ… .env file created successfully"
            echo "ğŸ“„ File size: $(wc -l < .env) lines"
            echo "âœ… All environment variables have been loaded from GitHub Secrets"
          else
            echo "âŒ Failed to create .env file"
            exit 1
          fi

      - name: Transfer .env file to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          source: ".env"
          target: "/tmp"
          strip_components: 0

      - name: Move .env file to correct location on server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory (with fallbacks)
            BASE_DIR="/opt/hrms"
            if [ ! -d "$BASE_DIR" ]; then
              BASE_DIR="$HOME/hrms"
              if [ ! -d "$BASE_DIR" ]; then
                BASE_DIR="/tmp/hrms"
              fi
              mkdir -p "$BASE_DIR" || {
                echo "âŒ Failed to create directory. Trying with sudo..."
                sudo mkdir -p /opt/hrms || mkdir -p ~/hrms || mkdir -p /tmp/hrms
                BASE_DIR="/opt/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="$HOME/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="/tmp/hrms"
              }
            fi

            # Create backend directory if it doesn't exist
            mkdir -p "$BASE_DIR/backend" || {
              echo "âŒ Failed to create backend directory"
              exit 1
            }

            # Move .env file to correct location
            if [ -f "/tmp/.env" ]; then
              mv /tmp/.env "$BASE_DIR/backend/.env"
              chmod 600 "$BASE_DIR/backend/.env"
              echo "âœ… .env file moved to $BASE_DIR/backend/.env"
              
              # Verify .env file
              if [ -f "$BASE_DIR/backend/.env" ]; then
                echo "âœ… .env file verified on server"
                echo "ğŸ“„ File size: $(wc -l < "$BASE_DIR/backend/.env") lines"
                # Show non-sensitive parts (masked)
                grep -E "^(DB_USER|DB_NAME|DB_HOST|DB_PORT|DB_DIALECT|NODE_ENV|PORT)=" "$BASE_DIR/backend/.env" | sed 's/=\(.*\)/=***/' || echo "âš ï¸  Some variables not found"
              else
                echo "âŒ ERROR: .env file not found after move"
                exit 1
              fi
            else
              echo "âŒ ERROR: .env file not found in /tmp"
              exit 1
            fi

      - name: Clean up local .env file
        if: always()
        run: |
          echo "ğŸ§¹ Cleaning up local .env file..."
          rm -f .env
          echo "âœ… Local .env file removed"

      - name: Deploy to Digital Ocean Droplet
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory (with fallbacks)
            BASE_DIR="/opt/hrms"
            if [ ! -d "$BASE_DIR" ]; then
              BASE_DIR="$HOME/hrms"
              if [ ! -d "$BASE_DIR" ]; then
                BASE_DIR="/tmp/hrms"
              fi
              mkdir -p "$BASE_DIR" || {
                echo "âŒ Failed to create directory. Trying with sudo..."
                sudo mkdir -p /opt/hrms || mkdir -p ~/hrms || mkdir -p /tmp/hrms
                BASE_DIR="/opt/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="$HOME/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="/tmp/hrms"
              }
            fi
            cd "$BASE_DIR" || exit 1

            # Check which docker compose command is available
            DOCKER_COMPOSE_CMD=""
            # Test docker-compose (standalone)
            if command -v docker-compose >/dev/null 2>&1; then
              if docker-compose --version >/dev/null 2>&1; then
                DOCKER_COMPOSE_CMD="docker-compose"
                echo "âœ… Found docker-compose (standalone)"
              fi
            fi
            # Test docker compose (plugin) if standalone not found
            if [ -z "$DOCKER_COMPOSE_CMD" ]; then
              if docker compose version >/dev/null 2>&1; then
                DOCKER_COMPOSE_CMD="docker compose"
                echo "âœ… Found docker compose (plugin)"
              fi
            fi
            # Error if neither is found
            if [ -z "$DOCKER_COMPOSE_CMD" ]; then
              echo "âŒ Error: Neither 'docker-compose' nor 'docker compose' is available."
              echo "Please install Docker Compose:"
              echo "  For plugin version (recommended):"
              echo "    sudo apt-get update && sudo apt-get install docker-compose-plugin"
              echo "  Or for standalone version:"
              echo "    sudo apt-get update && sudo apt-get install docker-compose"
              exit 1
            fi

            # Create shared network if it doesn't exist
            docker network create hrms-network --driver bridge 2>/dev/null || true

            # Ensure backend directory and docker-compose.yml exist
            if [ ! -d "backend" ]; then
              mkdir -p backend
              echo "âš ï¸  Backend directory not found, creating it..."
            fi
            if [ ! -f "backend/docker-compose.yml" ]; then
              echo "âŒ Error: backend/docker-compose.yml not found at $BASE_DIR/backend/"
              echo "Please ensure the docker-compose.yml file is present in the backend directory."
              exit 1
            fi

            # Start services (database will start first due to depends_on)
            # Note: Backend image is already pulled from GHCR and tagged as hrms-backend:latest, MySQL image will be pulled if needed
            cd backend

            # Export environment variables for docker-compose (from .env file)
            set -a
            source "$BASE_DIR/backend/.env"
            set +a

            # Check if containers are already running
            MYSQL_RUNNING=$($DOCKER_COMPOSE_CMD ps -q mysql 2>/dev/null || echo "")
            BACKEND_RUNNING=$($DOCKER_COMPOSE_CMD ps -q backend 2>/dev/null || echo "")

            if [ -z "$MYSQL_RUNNING" ]; then
              echo "ğŸš€ Starting MySQL container..."
              $DOCKER_COMPOSE_CMD up -d mysql
              echo "â³ Waiting for MySQL to be ready..."
              sleep 15
              
              # Grant permissions to user from any host (required for Docker network connections)
              echo "ğŸ”§ Granting database user permissions for Docker network connections..."
              
              # Get the actual root password from the container (it might differ from .env)
              ACTUAL_ROOT_PASSWORD=$(docker exec hrms-mysql printenv MYSQL_ROOT_PASSWORD 2>/dev/null || echo "$DB_ROOT_PASSWORD")
              
              # Use --password= syntax to avoid shell interpretation issues
              if docker exec hrms-mysql mysql -uroot --password="$ACTUAL_ROOT_PASSWORD" -e "
                -- Create user for any host (%) if it doesn't exist
                CREATE USER IF NOT EXISTS '$DB_USER'@'%' IDENTIFIED BY '$DB_PASSWORD';
                -- Grant all privileges to user from any host
                GRANT ALL PRIVILEGES ON \`$DB_NAME\`.* TO '$DB_USER'@'%';
                -- Also ensure user exists for localhost (for local connections)
                CREATE USER IF NOT EXISTS '$DB_USER'@'localhost' IDENTIFIED BY '$DB_PASSWORD';
                GRANT ALL PRIVILEGES ON \`$DB_NAME\`.* TO '$DB_USER'@'localhost';
                -- Flush privileges to apply changes
                FLUSH PRIVILEGES;
                SELECT 'Permissions granted successfully' AS status;
              " 2>&1 | grep -q "Permissions granted successfully"; then
                echo "âœ… MySQL user permissions configured"
              else
                echo "âš ï¸  Warning: Could not grant permissions (user might already exist with correct permissions)"
                echo "   This is OK if the database was already initialized"
              fi
            else
              echo "â„¹ï¸  MySQL container already running, skipping startup"
              # Still verify/update permissions in case they're missing
              echo "ğŸ”§ Verifying database user permissions..."
              
              # Get the actual root password from the container (it might differ from .env)
              ACTUAL_ROOT_PASSWORD=$(docker exec hrms-mysql printenv MYSQL_ROOT_PASSWORD 2>/dev/null || echo "$DB_ROOT_PASSWORD")
              
              # Try to grant permissions with the actual root password from container
              if docker exec hrms-mysql mysql -uroot --password="$ACTUAL_ROOT_PASSWORD" -e "
                -- Create user for any host (%) if it doesn't exist
                CREATE USER IF NOT EXISTS '$DB_USER'@'%' IDENTIFIED BY '$DB_PASSWORD';
                -- Grant permissions if user doesn't have them from %
                GRANT ALL PRIVILEGES ON \`$DB_NAME\`.* TO '$DB_USER'@'%';
                FLUSH PRIVILEGES;
                SELECT 'Permissions granted successfully' AS status;
              " 2>&1 | grep -q "Permissions granted successfully"; then
                echo "âœ… Permissions granted successfully"
              else
                echo "âš ï¸  Could not grant permissions automatically"
                echo "   Testing if user can already connect from Docker network..."
                
                # Test if user can connect by trying to query from within MySQL container
                # (simulating connection from Docker network)
                if docker exec hrms-mysql mysql -u"$DB_USER" --password="$DB_PASSWORD" -e "SELECT 1 AS test;" 2>&1 | grep -q "test"; then
                  echo "âœ… User can connect - permissions may already be correct"
                else
                  echo "âŒ User cannot connect - permissions need to be fixed"
                  echo ""
                  echo "ğŸ“‹ To fix this, run the following command on the server:"
                  echo "   docker exec -it hrms-mysql mysql -uroot -p"
                  echo "   Then run:"
                  echo "   CREATE USER IF NOT EXISTS '$DB_USER'@'%' IDENTIFIED BY '$DB_PASSWORD';"
                  echo "   GRANT ALL PRIVILEGES ON \`$DB_NAME\`.* TO '$DB_USER'@'%';"
                  echo "   FLUSH PRIVILEGES;"
                  echo ""
                  echo "   OR recreate the MySQL container:"
                  echo "   cd $BASE_DIR/backend"
                  echo "   docker compose down mysql"
                  echo "   docker volume rm backend_mysql_data  # WARNING: This deletes all data!"
                  echo "   docker compose up -d mysql"
                  echo ""
                  echo "âš ï¸  Migration will likely fail until permissions are fixed"
                fi
              fi
            fi

            # Test migrations in a NEW container with the new image before replacing the old one
            # This ensures we're testing with the latest code that includes sequelize-cli
            TEMP_CONTAINER_NAME="hrms-backend-migration-test-$$"
            MIGRATION_SUCCESS=false

            if [ -n "$BACKEND_RUNNING" ]; then
              echo "â„¹ï¸  Backend container already running with old image"
              echo "ğŸ§ª Testing migrations in a new temporary container with the new image..."
              echo "âš ï¸  If migrations fail, the old container will continue running"
              
              # Stop and remove temp container if it exists
              docker stop "$TEMP_CONTAINER_NAME" 2>/dev/null || true
              docker rm "$TEMP_CONTAINER_NAME" 2>/dev/null || true
              
              # Start temporary container with new image for migration testing
              echo "ğŸ“‹ Starting temporary container for migration testing..."
              
              # Verify .env file exists and has content
              if [ ! -f "$BASE_DIR/backend/.env" ]; then
                echo "âŒ .env file not found at $BASE_DIR/backend/.env"
                exit 1
              fi
              
              # Verify key database variables exist in .env file
              echo "ğŸ” Verifying .env file contains required variables..."
              if ! grep -q "^DB_USER=" "$BASE_DIR/backend/.env"; then
                echo "âŒ DB_USER not found in .env file"
                exit 1
              fi
              if ! grep -q "^DB_PASSWORD=" "$BASE_DIR/backend/.env"; then
                echo "âŒ DB_PASSWORD not found in .env file"
                exit 1
              fi
              if ! grep -q "^DB_HOST=" "$BASE_DIR/backend/.env"; then
                echo "âŒ DB_HOST not found in .env file"
                exit 1
              fi
              
              # Debug: Show DB variables (without showing passwords)
              echo "ğŸ“‹ Database configuration (masked):"
              grep "^DB_" "$BASE_DIR/backend/.env" | sed 's/\(PASSWORD\)=.*/\1=***/' || true
              
              # Start temporary container using --env-file (most reliable method)
              # This ensures all variables from .env are properly loaded
              docker run -d \
                --name "$TEMP_CONTAINER_NAME" \
                --network hrms-network \
                --env-file "$BASE_DIR/backend/.env" \
                hrms-backend:latest \
                sleep 3600 || {
                echo "âŒ Failed to start temporary backend container for migration testing"
                exit 1
              }
              
              # Verify container started and check environment variables
              echo "âœ… Container started, verifying environment variables..."
              sleep 2
              
              # Check if DB_USER is set in container (for debugging)
              DB_USER_CHECK=$(docker exec "$TEMP_CONTAINER_NAME" sh -c 'echo "$DB_USER"' 2>/dev/null || echo "")
              if [ -z "$DB_USER_CHECK" ]; then
                echo "âš ï¸  Warning: DB_USER appears to be empty in container"
                echo "ğŸ“‹ Checking all DB_* variables in container:"
                docker exec "$TEMP_CONTAINER_NAME" env | grep "^DB_" || echo "No DB_ variables found"
              else
                echo "âœ… DB_USER is set in container (value: ${DB_USER_CHECK:0:3}***)"
              fi
              
              # Also copy .env file into container for dotenv to read (as fallback)
              docker cp "$BASE_DIR/backend/.env" "$TEMP_CONTAINER_NAME:/app/.env" 2>/dev/null || {
                echo "âš ï¸  Warning: Could not copy .env file into container"
              }
              
              echo "â³ Waiting for temporary container to be ready..."
              sleep 10
              
              MIGRATION_CONTAINER="$TEMP_CONTAINER_NAME"
            else
              echo "ğŸš€ Starting backend container for first-time deployment..."
              $DOCKER_COMPOSE_CMD up -d --no-deps backend
              sleep 15
              MIGRATION_CONTAINER="backend"
            fi

            # Run migrations with automatic rollback on failure
            echo "ğŸ”„ Running database migrations (with auto-rollback on failure)..."
            echo "ğŸ“Š Capturing migration state before migration..."
            MIGRATION_STATE_BEFORE=$(docker exec "$MIGRATION_CONTAINER" npm run migrate:status 2>&1 || echo "")
            echo "$MIGRATION_STATE_BEFORE"

            # Run migrations using safe migration script (with automatic rollback)
            echo "ğŸš€ Starting safe migration process..."
            if docker exec "$MIGRATION_CONTAINER" npm run migrate:safe; then
              echo "âœ… Migrations completed successfully"
              # Verify final migration status
              echo "ğŸ“Š Verifying final migration status..."
              docker exec "$MIGRATION_CONTAINER" npm run migrate:status
              echo "âœ… All migrations verified and database is in correct state"
              MIGRATION_SUCCESS=true
            else
              echo "âŒ Migration failed! Rollback was attempted automatically."
              echo "ğŸ“‹ Showing backend logs for debugging..."
              docker logs --tail=50 "$MIGRATION_CONTAINER"
              echo ""
              echo "ğŸ“Š Current migration status after rollback:"
              docker exec "$MIGRATION_CONTAINER" npm run migrate:status || true
              echo ""
              echo "âŒ Deployment stopped due to migration failure."
              echo "ğŸ“‹ Database has been rolled back to previous state."
              
              # Clean up temporary container
              if [ -n "$BACKEND_RUNNING" ]; then
                echo "ğŸ“‹ Previous backend container is still running - no changes made."
                docker stop "$TEMP_CONTAINER_NAME" 2>/dev/null || true
                docker rm "$TEMP_CONTAINER_NAME" 2>/dev/null || true
              fi
              echo "ğŸ“‹ Please fix migration issues and try again."
              exit 1
            fi

            # Only if migration succeeded, replace the old container with the new one
            if [ "$MIGRATION_SUCCESS" = true ]; then
              if [ -n "$BACKEND_RUNNING" ]; then
                echo "ğŸ”„ Migrations successful! Replacing old backend container with new one..."
                
                # Stop and remove temporary container
                docker stop "$TEMP_CONTAINER_NAME" 2>/dev/null || true
                docker rm "$TEMP_CONTAINER_NAME" 2>/dev/null || true
                
                # Stop old backend container
                echo "ğŸ›‘ Stopping old backend container..."
                $DOCKER_COMPOSE_CMD stop backend
                $DOCKER_COMPOSE_CMD rm -f backend
                
                # Start new backend container with the new image
                echo "ğŸš€ Starting new backend container with migrated database..."
                $DOCKER_COMPOSE_CMD up -d --no-deps backend
                
                # Wait for new container to be ready
                echo "â³ Waiting for new backend container to be ready..."
                sleep 10
                
                # Verify new container is running
                if $DOCKER_COMPOSE_CMD ps backend | grep -q "Up"; then
                  echo "âœ… New backend container is running successfully"
                else
                  echo "âš ï¸  Warning: Backend container may not be running properly"
                  $DOCKER_COMPOSE_CMD ps backend
                fi
              else
                echo "âœ… Backend container is running with migrated database"
              fi
            fi

            # Clean up unused Docker resources (only after successful deployment)
            if [ "$MIGRATION_SUCCESS" = true ]; then
              echo "ğŸ§¹ Cleaning up unused Docker resources..."
              
              # Show disk usage before cleanup
              echo "ğŸ“Š Disk usage before cleanup:"
              docker system df
              
              # Remove stopped containers
              echo "ğŸ—‘ï¸  Removing stopped containers..."
              docker container prune -f
              
              # Remove unused images (but keep images that are in use)
              echo "ğŸ—‘ï¸  Removing unused images..."
              docker image prune -af --filter "until=24h" || docker image prune -af
              
              # Remove unused volumes (but keep named volumes like mysql_data)
              echo "ğŸ—‘ï¸  Removing unused volumes..."
              docker volume prune -f
              
              # Remove unused networks (but keep hrms-network)
              echo "ğŸ—‘ï¸  Removing unused networks..."
              docker network prune -f
              
              # Show disk usage after cleanup
              echo "ğŸ“Š Disk usage after cleanup:"
              docker system df
              
              echo "âœ… Docker cleanup completed"
            fi

      - name: Health Check
        run: |
          sleep 10
          curl -f ${{ secrets.DEPLOY_URL }}/api/health || exit 1
