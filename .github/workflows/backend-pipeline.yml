name: Backend CI/CD Pipeline


on:
  push:
    branches:
      - main
    paths:
      - "backend/**"
      - ".github/workflows/backend-pipeline.yml"
  pull_request:
    branches:
      - main
    paths:
      - "backend/**"
      - ".github/workflows/backend-pipeline.yml"
  workflow_dispatch:

env:
  NODE_VERSION: "18"
  IMAGE_NAME: hrms-backend
  REGISTRY: ghcr.io
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Testing Job
  test:
    name: Unit & Integration Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Start MySQL test database with Docker Compose
        working-directory: ./backend
        run: |
          echo "üöÄ Starting MySQL test database..."
          docker compose -f docker-compose.test.yml up -d
          echo "‚úÖ MySQL container started"

      - name: Wait for MySQL to be ready
        working-directory: ./backend
        run: |
          echo "‚è≥ Waiting for MySQL to be ready..."

          # Wait for container to be running
          echo "Checking container status..."
          for i in {1..30}; do
            CONTAINER_STATUS=$(docker compose -f docker-compose.test.yml ps mysql-test --format json 2>/dev/null | grep -o '"State":"[^"]*"' | cut -d'"' -f4 || echo "")
            if [ "$CONTAINER_STATUS" = "running" ]; then
              echo "‚úÖ Container is running"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "‚ùå Container failed to start"
              docker compose -f docker-compose.test.yml ps -a
              docker compose -f docker-compose.test.yml logs mysql-test
              exit 1
            fi
            echo "Waiting for container... ($i/30)"
            sleep 2
          done

          # Wait for MySQL to accept connections (give it time to initialize)
          echo "Waiting for MySQL to initialize and accept connections..."
          echo "This may take 30-60 seconds for MySQL 8.0..."

          for i in {1..90}; do
            # Try mysqladmin ping inside the container
            if docker compose -f docker-compose.test.yml exec -T mysql-test mysqladmin ping -h localhost -u root -ptestpassword --silent 2>/dev/null; then
              echo "‚úÖ MySQL is ready and accepting connections!"
              break
            fi
            
            if [ $i -eq 90 ]; then
              echo "‚ùå MySQL failed to start after 3 minutes"
              echo "üìã Container logs (last 100 lines):"
              docker compose -f docker-compose.test.yml logs --tail=100 mysql-test
              echo ""
              echo "üìä Container status:"
              docker compose -f docker-compose.test.yml ps
              echo ""
              echo "üîç Testing connection manually:"
              docker compose -f docker-compose.test.yml exec -T mysql-test mysqladmin ping -h localhost -u root -ptestpassword || true
              exit 1
            fi
            
            # Show progress every 10 iterations
            if [ $((i % 10)) -eq 0 ]; then
              echo "Still waiting... ($i/90) - MySQL is initializing..."
            fi
            sleep 2
          done

          # Give MySQL additional time to fully initialize
          echo "‚è≥ Waiting additional 5 seconds for MySQL to fully initialize..."
          sleep 5
          echo "‚úÖ MySQL is ready!"

      - name: Configure MySQL
        working-directory: ./backend
        run: |
          echo "üîß Configuring MySQL settings..."

          # Verify connection first
          echo "Verifying MySQL connection..."
          docker compose -f docker-compose.test.yml exec -T mysql-test mysqladmin ping -h localhost -u root -ptestpassword || {
            echo "‚ùå Failed to connect to MySQL"
            docker compose -f docker-compose.test.yml logs --tail=20 mysql-test
            exit 1
          }

          # Configure database settings
          echo "Configuring database character set..."
          docker compose -f docker-compose.test.yml exec -T mysql-test mysql -u root -ptestpassword -e "ALTER DATABASE test_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;" 2>&1 || echo "‚ö†Ô∏è  Character set configuration skipped (may already be set)"

          # Verify database exists
          echo "Verifying test_db database..."
          docker compose -f docker-compose.test.yml exec -T mysql-test mysql -u root -ptestpassword -e "SHOW DATABASES LIKE 'test_db';" | grep test_db || {
            echo "‚ùå test_db database not found!"
            exit 1
          }

          echo "‚úÖ MySQL configuration completed"

      - name: Run database migrations (test)
        working-directory: ./backend
        run: |
          echo "üîÑ Running database migrations..."
          npm run migrate
          if [ $? -ne 0 ]; then
            echo "‚ùå Migration failed!"
            exit 1
          fi
          echo "‚úÖ Migrations completed successfully"
        env:
          NODE_ENV: test
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: testpassword
          DB_NAME: test_db
          DB_PORT: 3307
          DB_DIALECT: mysql

      - name: Verify migration status (test)
        working-directory: ./backend
        run: |
          echo "üìä Checking migration status..."
          npm run migrate:status
          if [ $? -ne 0 ]; then
            echo "‚ùå Migration status check failed!"
            exit 1
          fi
          echo "‚úÖ All migrations are up to date"
        env:
          NODE_ENV: test
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: testpassword
          DB_NAME: test_db
          DB_PORT: 3307
          DB_DIALECT: mysql

      - name: Run unit tests
        working-directory: ./backend
        run: npm run test:unit
        env:
          NODE_ENV: test
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: testpassword
          DB_NAME: test_db
          DB_PORT: 3307
          DB_DIALECT: mysql
          JWT_SECRET: test_jwt_secret

      - name: Run integration tests
        working-directory: ./backend
        run: npm run test:integration
        continue-on-error: true
        env:
          NODE_ENV: test
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: testpassword
          DB_NAME: test_db
          DB_PORT: 3307
          DB_DIALECT: mysql
          JWT_SECRET: test_jwt_secret

      - name: Upload test coverage
        uses: codecov/codecov-action@v3
        if: always()
        with:
          files: ./backend/coverage/coverage-final.json
          flags: backend
          name: backend-coverage
        continue-on-error: true

      - name: Stop MySQL test database
        if: always()
        working-directory: ./backend
        run: |
          echo "üõë Stopping MySQL test database..."
          docker compose -f docker-compose.test.yml down -v || true
          echo "‚úÖ MySQL test database stopped"

  # Linting Job
  lint:
    name: Code Linting
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run ESLint
        working-directory: ./backend
        run: npm run lint

      - name: Check code formatting
        working-directory: ./backend
        run: npm run lint:format
        continue-on-error: true

  # Security Scanning (SCA - Software Composition Analysis)
  security-scan:
    name: Security Vulnerability Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run npm audit
        working-directory: ./backend
        run: npm audit --audit-level=moderate
        continue-on-error: true

      - name: Install Snyk
        continue-on-error: true
        run: npm install -g snyk

      - name: Run Snyk security scan
        continue-on-error: true
        working-directory: ./backend
        run: |
          if [ -n "${{ secrets.SNYK_TOKEN }}" ]; then
            snyk auth ${{ secrets.SNYK_TOKEN }} || true
            snyk test --severity-threshold=high || true
          else
            echo "Snyk token not configured, skipping scan"
          fi
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  # Static Code Analysis (SAST + CodeQL)
  code-analysis:
    name: Static Code Analysis
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run Sonar Scan
        uses: SonarSource/sonarqube-scan-action@v5.0.0
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          projectBaseDir: ./backend
          args: >
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.sources=.
            -Dsonar.exclusions=**/node_modules/**,**/coverage/**,**/tests/**,**/*.test.js
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v2
        continue-on-error: true
        with:
          languages: javascript
          queries: security-extended,security-and-quality

      - name: Autobuild
        uses: github/codeql-action/autobuild@v2
        continue-on-error: true

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v2
        continue-on-error: true

  # Build Job
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [test, lint, security-scan, code-analysis]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Verify syntax
        working-directory: ./backend
        run: node --check index.js

      - name: Build application
        working-directory: ./backend
        run: npm run build

  # Docker Build Job
  docker-build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,format=long
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify image was pushed
        run: |
          echo "‚úÖ Image pushed to GHCR with tags:"
          echo "${{ steps.meta.outputs.tags }}"

  # Deploy to Digital Ocean
  deploy:
    name: Deploy to Digital Ocean
    runs-on: ubuntu-latest
    needs: [docker-build]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    environment:
      name: Production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pull Docker image from GHCR on server
        uses: appleboy/ssh-action@v1.0.0
        env:
          GHCR_TOKEN: ${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            echo "üì¶ Pulling Docker image from GHCR..."
            REGISTRY="ghcr.io"
            REPO_OWNER_ORIGINAL="${{ github.repository_owner }}"
            REPO_OWNER_LOWER=$(echo "${REPO_OWNER_ORIGINAL}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="${{ env.IMAGE_NAME }}"
            IMAGE_FULL_NAME="${REGISTRY}/${REPO_OWNER_LOWER}/${IMAGE_NAME}:latest"
            echo "Image: ${IMAGE_FULL_NAME}"

            # Login to GHCR using Personal Access Token or GITHUB_TOKEN
            if [ -n "${GHCR_TOKEN}" ]; then
              echo "${GHCR_TOKEN}" | docker login ${REGISTRY} -u ${REPO_OWNER_ORIGINAL} --password-stdin
              echo "‚úÖ Logged in to GHCR"
            else
              echo "‚ö†Ô∏è  No GHCR token found. Attempting public pull (may fail if package is private)..."
            fi

            # Pull the image
            if docker pull "${IMAGE_FULL_NAME}"; then
              echo "‚úÖ Image pulled successfully"
            else
              echo "‚ùå Failed to pull image. Please ensure:"
              echo "   1. GHCR_PAT secret is set in GitHub Secrets (Production environment)"
              echo "   2. The package permissions allow the token to read"
              echo "   3. The image exists in GHCR: ${IMAGE_FULL_NAME}"
              exit 1
            fi

            # Tag it for local use (docker-compose expects hrms-backend:latest)
            docker tag "${IMAGE_FULL_NAME}" "${IMAGE_NAME}:latest"
            echo "‚úÖ Docker image pulled and tagged as ${IMAGE_NAME}:latest"
            docker images | grep "${IMAGE_NAME}" || true

      - name: Transfer docker-compose.yml to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          source: "backend/docker-compose.yml"
          target: "/tmp/"
          overwrite: true

      - name: Setup backend directory structure on server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory
            BASE_DIR="/home/huzaifa/hrms"
            mkdir -p "$BASE_DIR/backend" || {
              echo "‚ùå Failed to create directory: $BASE_DIR/backend"
              exit 1
            }

            # Find and move docker-compose.yml to backend directory
            echo "üîç Searching for docker-compose.yml..."
            DOCKER_COMPOSE_FILE=""

            # Check common locations
            if [ -f "/tmp/docker-compose.yml" ]; then
              DOCKER_COMPOSE_FILE="/tmp/docker-compose.yml"
            elif [ -f "$HOME/docker-compose.yml" ]; then
              DOCKER_COMPOSE_FILE="$HOME/docker-compose.yml"
            else
              # Search in /tmp for any docker-compose.yml
              DOCKER_COMPOSE_FILE=$(find /tmp -name "docker-compose.yml" -type f 2>/dev/null | head -1)
            fi

            if [ -n "$DOCKER_COMPOSE_FILE" ] && [ -f "$DOCKER_COMPOSE_FILE" ]; then
              echo "‚úÖ Found docker-compose.yml at: $DOCKER_COMPOSE_FILE"
              # Try to move it to the backend directory
              if cp "$DOCKER_COMPOSE_FILE" "$BASE_DIR/backend/docker-compose.yml" 2>/dev/null || \
                 sudo cp "$DOCKER_COMPOSE_FILE" "$BASE_DIR/backend/docker-compose.yml" 2>/dev/null || \
                 cp "$DOCKER_COMPOSE_FILE" "$HOME/hrms/backend/docker-compose.yml" 2>/dev/null || \
                 cp "$DOCKER_COMPOSE_FILE" "/tmp/hrms/backend/docker-compose.yml" 2>/dev/null; then
                echo "‚úÖ docker-compose.yml copied to $BASE_DIR/backend/"
                # Remove the temporary file
                rm -f "$DOCKER_COMPOSE_FILE" 2>/dev/null || true
              else
                echo "‚ùå Failed to copy docker-compose.yml to backend directory"
                exit 1
              fi
            else
              echo "‚ùå docker-compose.yml not found in expected locations"
              echo "üìã Contents of /tmp:"
              ls -la /tmp/ | grep -i docker || echo "No docker files found"
              echo "üìã Searching entire /tmp:"
              find /tmp -name "*docker*" -type f 2>/dev/null | head -5 || echo "No docker files found"
              exit 1
            fi

            # Verify the file exists in the backend directory
            if [ ! -f "$BASE_DIR/backend/docker-compose.yml" ]; then
              echo "‚ùå docker-compose.yml not found at $BASE_DIR/backend/docker-compose.yml after copy"
              exit 1
            fi
            echo "‚úÖ Verified docker-compose.yml exists at $BASE_DIR/backend/docker-compose.yml"

      - name: Verify secrets are accessible
        run: |
          echo "üîç Verifying secrets are accessible in workflow..."
          echo "üìã Note: When using 'environment: Production', secrets must be in Production environment"
          echo ""

          DB_USER_ACCESSIBLE="${{ secrets.DB_USER }}"
          DB_PASSWORD_ACCESSIBLE="${{ secrets.DB_PASSWORD }}"
          DB_NAME_ACCESSIBLE="${{ secrets.DB_NAME }}"

          if [ -z "$DB_USER_ACCESSIBLE" ]; then
            echo "‚ùå ERROR: DB_USER secret is not accessible"
            exit 1
          fi

          if [ -z "$DB_PASSWORD_ACCESSIBLE" ]; then
            echo "‚ùå ERROR: DB_PASSWORD secret is not accessible"
            exit 1
          fi

          if [ -z "$DB_NAME_ACCESSIBLE" ]; then
            echo "‚ùå ERROR: DB_NAME secret is not accessible"
            exit 1
          fi

          echo "‚úÖ All required secrets are accessible in workflow"
          echo "‚úÖ Secrets are being read from: Production environment"

      - name: Create .env file from GitHub Secrets
        run: |
          echo "üîê Creating .env file from GitHub Secrets..."

          write_env() {
            local key=$1
            local value=$2
            
            if [ -z "$value" ]; then
              echo "${key}=" >> .env
              return
            fi
            
            needs_quoting=false
            
            if [[ "$value" =~ [[:space:]] ]]; then
              needs_quoting=true
            fi
            if [[ "$value" =~ [\$\\\`\"\'\!\@\#\^\&\*\(\)\[\]\{\}\|\;\<\>\?] ]]; then
              needs_quoting=true
            fi
            if [[ "$value" =~ ^- ]]; then
              needs_quoting=true
            fi
            if [ "$needs_quoting" = false ]; then
              if ! [[ "$value" =~ ^[a-zA-Z0-9_\.\-\:\/\+=]+$ ]]; then
                needs_quoting=true
              fi
            fi
            
            if [ "$needs_quoting" = true ]; then
              escaped_value=$(printf '%s' "$value" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed 's/\$/\\$/g' | sed 's/`/\\`/g')
              echo "${key}=\"${escaped_value}\"" >> .env
            else
              echo "${key}=${value}" >> .env
            fi
          }

          if [ -z "${{ secrets.DB_USER }}" ]; then
            echo "‚ùå ERROR: DB_USER secret is not accessible in Production environment"
            exit 1
          fi
          if [ -z "${{ secrets.DB_PASSWORD }}" ]; then
            echo "‚ùå ERROR: DB_PASSWORD secret is not accessible in Production environment"
            exit 1
          fi
          if [ -z "${{ secrets.DB_NAME }}" ]; then
            echo "‚ùå ERROR: DB_NAME secret is not accessible in Production environment"
            exit 1
          fi

          echo "# ==========================================" > .env
          echo "# HRMS Application Environment Variables" >> .env
          echo "# Auto-generated from GitHub Secrets" >> .env
          echo "# ==========================================" >> .env
          echo "" >> .env

          echo "# Application Configuration" >> .env
          write_env "NODE_ENV" "production"
          write_env "PORT" "8000"
          echo "" >> .env

          echo "# Database Configuration" >> .env
          write_env "DB_ROOT_PASSWORD" "${{ secrets.DB_ROOT_PASSWORD }}"
          write_env "DB_NAME" "${{ secrets.DB_NAME }}"
          write_env "DB_USER" "${{ secrets.DB_USER }}"
          write_env "DB_PASSWORD" "${{ secrets.DB_PASSWORD }}"
          write_env "DB_PORT" "${{ secrets.DB_PORT || '3306' }}"
          write_env "DB_DIALECT" "${{ secrets.DB_DIALECT || 'mysql' }}"
          write_env "DB_HOST" "mysql"
          echo "" >> .env

          echo "# Security & Authentication" >> .env
          write_env "JWT_SECRET" "${{ secrets.JWT_SECRET }}"
          echo "" >> .env

          echo "# Email Configuration (SendGrid)" >> .env
          write_env "SENDGRID_API_KEY" "${{ secrets.SENDGRID_API_KEY }}"
          write_env "EMAIL_FROM" "${{ secrets.EMAIL_FROM || 'no-reply@kitor.io' }}"
          write_env "EMAIL_FROM_NAME" "${{ secrets.EMAIL_FROM_NAME || 'Xylobit HRMS' }}"
          echo "" >> .env

          echo "# URL Configuration" >> .env
          write_env "FRONTEND_URL" "${{ secrets.FRONTEND_URL }}"
          write_env "DOMAIN" "${{ secrets.DOMAIN }}"
          write_env "BACKEND_URL" "${{ secrets.BACKEND_URL }}"
          echo "" >> .env

          echo "# Frontend Environment Variables (React - for docker-compose)" >> .env
          write_env "REACT_APP_BACKEND_URL" "${{ secrets.REACT_APP_BACKEND_URL }}"
          write_env "REACT_APP_FRONTEND_URL" "${{ secrets.REACT_APP_FRONTEND_URL }}"
          echo "" >> .env

          echo "# AWS S3 Configuration (File Storage)" >> .env
          write_env "AWS_ACCESS_KEY_ID" "${{ secrets.AWS_ACCESS_KEY_ID }}"
          write_env "AWS_SECRET_ACCESS_KEY" "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          write_env "AWS_REGION" "${{ secrets.AWS_REGION }}"
          write_env "AWS_S3_BUCKET_NAME" "${{ secrets.AWS_S3_BUCKET_NAME }}"

          if [ -f .env ]; then
            echo "‚úÖ .env file created successfully"
            echo "üìÑ File size: $(wc -l < .env) lines"
          else
            echo "‚ùå Failed to create .env file"
            exit 1
          fi

      - name: Transfer .env file to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          source: ".env"
          target: "/tmp"
          strip_components: 0

      - name: Move .env file to correct location on server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            BASE_DIR="/home/huzaifa/hrms"
            mkdir -p "$BASE_DIR/backend" || {
              echo "‚ùå Failed to create backend directory: $BASE_DIR/backend"
              exit 1
            }

            if [ -f "/tmp/.env" ]; then
              mv /tmp/.env "$BASE_DIR/backend/.env"
              chmod 600 "$BASE_DIR/backend/.env"
              echo "‚úÖ .env file moved to $BASE_DIR/backend/.env"
              
              if [ -f "$BASE_DIR/backend/.env" ]; then
                echo "‚úÖ .env file verified on server"
                echo "üìÑ File size: $(wc -l < "$BASE_DIR/backend/.env") lines"
                grep -E "^(DB_USER|DB_NAME|DB_HOST|DB_PORT|DB_DIALECT|NODE_ENV|PORT)=" "$BASE_DIR/backend/.env" | sed 's/=\(.*\)/=***/' || echo "‚ö†Ô∏è  Some variables not found"
              else
                echo "‚ùå ERROR: .env file not found after move"
                exit 1
              fi
            else
              echo "‚ùå ERROR: .env file not found in /tmp"
              exit 1
            fi

      - name: Clean up local .env file
        if: always()
        run: |
          echo "üßπ Cleaning up local .env file..."
          rm -f .env
          echo "‚úÖ Local .env file removed"

      - name: Deploy to Digital Ocean Droplet
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory
            BASE_DIR="/home/huzaifa/hrms"
            mkdir -p "$BASE_DIR" || {
              echo "‚ùå Failed to create directory: $BASE_DIR"
              exit 1
            }
            cd "$BASE_DIR" || exit 1

            # Check which docker compose command is available
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose >/dev/null 2>&1 && docker-compose --version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker-compose"
              echo "‚úÖ Found docker-compose (standalone)"
            elif docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
              echo "‚úÖ Found docker compose (plugin)"
            else
              echo "‚ùå Error: Neither 'docker-compose' nor 'docker compose' is available."
              echo "Please install Docker Compose:"
              echo "  sudo apt-get update && sudo apt-get install docker-compose-plugin"
              exit 1
            fi

            # Create shared network if it doesn't exist
            if ! docker network inspect hrms-network >/dev/null 2>&1; then
              echo "üì° Creating hrms-network..."
              docker network create hrms-network --driver bridge
            else
              echo "‚úÖ hrms-network already exists"
            fi

            # Ensure backend directory and docker-compose.yml exist
            if [ ! -d "backend" ]; then
              mkdir -p backend
              echo "‚ö†Ô∏è  Backend directory not found, creating it..."
            fi
            if [ ! -f "backend/docker-compose.yml" ]; then
              echo "‚ùå Error: backend/docker-compose.yml not found at $BASE_DIR/backend/"
              exit 1
            fi

            cd backend

            # Load env vars
            if [ ! -f ".env" ]; then
              echo "‚ùå .env file not found in $BASE_DIR/backend/.env"
              exit 1
            fi

            set -a
            source "$BASE_DIR/backend/.env"
            set +a

            # Clean up any existing containers to avoid conflicts
            # IMPORTANT: Only clean up backend-related containers, NOT nginx or frontend
            # CRITICAL: Preserve MySQL data volume to prevent data loss
            echo "üßπ Cleaning up existing backend containers..."

            # Check if MySQL volume exists before cleanup
            echo "üì¶ Checking MySQL data volume..."
            MYSQL_VOLUME_NAME="hrms_mysql_data"
            if docker volume inspect "$MYSQL_VOLUME_NAME" >/dev/null 2>&1; then
              echo "‚úÖ MySQL data volume exists: $MYSQL_VOLUME_NAME"
              VOLUME_EXISTS=true
            else
              echo "‚ö†Ô∏è  MySQL data volume not found: $MYSQL_VOLUME_NAME"
              VOLUME_EXISTS=false
            fi

            # Stop and remove containers using docker-compose with explicit project name
            # This only affects containers defined in backend/docker-compose.yml
            # CRITICAL: We use --remove-orphans but NOT -v to preserve MySQL data volume
            # The -v flag would remove volumes, which would delete all database data!
            echo "üõë Stopping backend containers (preserving volumes)..."
            $DOCKER_COMPOSE_CMD -p hrms down --remove-orphans 2>/dev/null || true

            # Force remove only backend-related containers (not nginx or frontend)
            # Explicitly target only hrms-mysql and hrms-backend
            # Do NOT remove: hrms-nginx, hrms-frontend, hrms-certbot
            # Note: docker rm does NOT remove volumes, only containers
            echo "Removing backend containers: hrms-mysql, hrms-backend"
            docker rm -f hrms-mysql hrms-backend 2>/dev/null || true

            # Verify MySQL volume still exists after cleanup
            if docker volume inspect "$MYSQL_VOLUME_NAME" >/dev/null 2>&1; then
              echo "‚úÖ MySQL data volume preserved: $MYSQL_VOLUME_NAME"
            else
              if [ "$VOLUME_EXISTS" = "true" ]; then
                echo "‚ùå WARNING: MySQL data volume was removed! This should not happen."
                echo "   The volume should have been preserved."
              else
                echo "‚ÑπÔ∏è  MySQL data volume will be created on first start"
              fi
            fi

            # Verify we're NOT touching nginx or frontend containers
            echo "‚úÖ Preserving nginx and frontend containers (hrms-nginx, hrms-frontend, hrms-certbot)"

            # Show what containers are still running (should include nginx and frontend)
            echo "üìã Remaining containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}" | grep -E "hrms-|NAMES" || true

            # Small delay to ensure cleanup is complete
            sleep 2

            # Ensure MySQL service is running
            echo "üöÄ Ensuring MySQL service is running..."
            $DOCKER_COMPOSE_CMD -p hrms up -d mysql

            # Verify MySQL volume is being used
            echo "üì¶ Verifying MySQL data volume..."
            sleep 2  # Give MySQL a moment to start
            if docker volume inspect hrms_mysql_data >/dev/null 2>&1; then
              echo "‚úÖ MySQL data volume is present: hrms_mysql_data"
              VOLUME_INFO=$(docker volume inspect hrms_mysql_data --format '{{.Mountpoint}}' 2>/dev/null || echo "")
              if [ -n "$VOLUME_INFO" ]; then
                echo "   Volume mount point: $VOLUME_INFO"
              fi
            else
              echo "‚ö†Ô∏è  MySQL data volume not found, it will be created"
            fi

            # Wait for MySQL to be ready (using root or DB user)
            MYSQL_ADMIN_USER="root"
            MYSQL_ADMIN_PASSWORD="${DB_ROOT_PASSWORD:-$DB_PASSWORD}"

            echo "‚è≥ Waiting for MySQL to be ready..."
            for i in {1..30}; do
              if $DOCKER_COMPOSE_CMD -p hrms exec -T mysql mysqladmin ping -h "localhost" -u"$MYSQL_ADMIN_USER" --password="$MYSQL_ADMIN_PASSWORD" --silent 2>/dev/null; then
                echo "‚úÖ MySQL is ready"
                break
              fi

              if [ $i -eq 30 ]; then
                echo "‚ùå MySQL did not become ready in time"
                echo "üìã Container status:"
                $DOCKER_COMPOSE_CMD -p hrms ps -a || true
                echo "üìã MySQL logs:"
                $DOCKER_COMPOSE_CMD -p hrms logs mysql --tail=100 || true
                echo "üìã All containers:"
                docker ps -a --filter "name=hrms-" || true
                exit 1
              fi

              echo "Waiting for MySQL... ($i/30)"
              sleep 2
            done

            # Give MySQL a moment to fully stabilize after health check
            echo "‚è≥ Waiting additional 3 seconds for MySQL to fully stabilize..."
            sleep 3

            # Verify MySQL is accessible from network
            echo "üîç Verifying MySQL network connectivity..."
            if $DOCKER_COMPOSE_CMD -p hrms exec -T mysql mysqladmin ping -h "localhost" -u"$MYSQL_ADMIN_USER" --password="$MYSQL_ADMIN_PASSWORD" --silent 2>/dev/null; then
              echo "‚úÖ MySQL is accessible and ready for migrations"
            else
              echo "‚ùå MySQL is not accessible"
              exit 1
            fi

            # Verify .env file has correct DB_HOST
            echo "üîç Verifying .env file configuration..."
            if [ -f ".env" ]; then
              ENV_DB_HOST=$(grep "^DB_HOST=" .env | cut -d'=' -f2 | tr -d '"' || echo "")
              if [ "$ENV_DB_HOST" != "mysql" ]; then
                echo "‚ö†Ô∏è  Warning: .env file has DB_HOST=$ENV_DB_HOST, expected 'mysql'"
                echo "   Updating .env file to use DB_HOST=mysql..."
                sed -i 's/^DB_HOST=.*/DB_HOST=mysql/' .env || {
                  echo "   Adding DB_HOST=mysql to .env..."
                  echo "DB_HOST=mysql" >> .env
                }
                echo "‚úÖ .env file updated"
              else
                echo "‚úÖ .env file has correct DB_HOST=mysql"
              fi
            else
              echo "‚ö†Ô∏è  .env file not found, but environment variables will be passed directly"
            fi

            # Run migrations in a one-off backend container
            # Note: docker compose run creates a temporary container with a unique name
            # This is expected behavior - the container name will be something like "hrms-backend-<hash>"
            echo "üîÑ Running database migrations (npm run migrate:safe)..."
            echo "üìã Migration container will use:"
            echo "   - DB_HOST=mysql"
            echo "   - DB_USER=${DB_USER}"
            echo "   - DB_NAME=${DB_NAME}"
            echo "   - DOCKER_ENV=true"
            echo "   - Network: hrms-network"

            # Debug: Check what DB_HOST is set to in the environment
            echo "üîç Debug: Current DB_HOST in shell: ${DB_HOST:-not set}"
            echo "üîç Debug: Current DOCKER_ENV in shell: ${DOCKER_ENV:-not set}"

            # Pass all necessary environment variables to the migration container
            # IMPORTANT: Environment variables passed with -e take precedence over .env file
            # The container needs to be on the same network and have all DB credentials
            # Note: docker compose run automatically uses the network from docker-compose.yml
            # We also set DEBUG=true temporarily to see what's happening
            if $DOCKER_COMPOSE_CMD -p hrms run --rm \
              -e DOCKER_ENV=true \
              -e NODE_ENV=production \
              -e DEBUG=true \
              -e DB_HOST=mysql \
              -e DB_USER="${DB_USER}" \
              -e DB_PASSWORD="${DB_PASSWORD}" \
              -e DB_NAME="${DB_NAME}" \
              -e DB_PORT=3306 \
              -e DB_DIALECT=mysql \
              backend sh -lc "
                echo 'üîç Debug: Environment variables inside container:'
                echo '   DB_HOST='\''${DB_HOST:-not set}'\'
                echo '   DOCKER_ENV='\''${DOCKER_ENV:-not set}'\'
                echo '   DB_USER='\''${DB_USER:-not set}'\'
                echo '   DB_NAME='\''${DB_NAME:-not set}'\'
                echo '   NODE_ENV='\''${NODE_ENV:-not set}'\'
                echo '   DB_PORT='\''${DB_PORT:-not set}'\'
                echo ''
                echo 'üîç Testing MySQL connection from container...'
                nc -zv mysql 3306 2>&1 || echo '‚ö†Ô∏è  nc test failed (this is OK if nc is not installed)'
                echo ''
                npm run migrate:safe
              "; then
              echo "‚úÖ Migrations completed successfully"
            else
              echo "‚ùå Migration failed. Not starting new backend container."
              echo "üìã Checking MySQL container status..."
              $DOCKER_COMPOSE_CMD -p hrms ps mysql || true
              echo "üìã Checking MySQL logs..."
              $DOCKER_COMPOSE_CMD -p hrms logs mysql --tail=30 || true
              echo "üìã Testing network connectivity..."
              docker network inspect hrms-network || true
              exit 1
            fi

            # Start/restart backend service
            echo "üöÄ Starting backend service..."
            $DOCKER_COMPOSE_CMD -p hrms up -d backend

            echo "üìä Current service status:"
            $DOCKER_COMPOSE_CMD -p hrms ps

      - name: Health Check
        run: |
          sleep 10
          curl -f ${{ secrets.DEPLOY_URL }}/api/health || exit 1
