name: Backend CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
    paths:
      - "backend/**"
  pull_request:
    branches:
      - main
      - develop
    paths:
      - "backend/**"
  workflow_dispatch:

env:
  NODE_VERSION: "18"
  IMAGE_NAME: hrms-backend
  REGISTRY: ghcr.io
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Testing Job
  test:
    name: Unit & Integration Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Start MySQL test database with Docker Compose
        working-directory: ./backend
        run: |
          echo "ğŸš€ Starting MySQL test database..."
          docker compose -f docker-compose.test.yml up -d
          echo "âœ… MySQL container started"

      - name: Wait for MySQL to be ready
        working-directory: ./backend
        run: |
          echo "â³ Waiting for MySQL to be ready..."

          # Wait for container to be running
          echo "Checking container status..."
          for i in {1..30}; do
            CONTAINER_STATUS=$(docker compose -f docker-compose.test.yml ps mysql-test --format json 2>/dev/null | grep -o '"State":"[^"]*"' | cut -d'"' -f4 || echo "")
            if [ "$CONTAINER_STATUS" = "running" ]; then
              echo "âœ… Container is running"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ Container failed to start"
              docker compose -f docker-compose.test.yml ps -a
              docker compose -f docker-compose.test.yml logs mysql-test
              exit 1
            fi
            echo "Waiting for container... ($i/30)"
            sleep 2
          done

          # Wait for MySQL to accept connections (give it time to initialize)
          echo "Waiting for MySQL to initialize and accept connections..."
          echo "This may take 30-60 seconds for MySQL 8.0..."

          for i in {1..90}; do
            # Try mysqladmin ping inside the container
            if docker compose -f docker-compose.test.yml exec -T mysql-test mysqladmin ping -h localhost -u root -ptestpassword --silent 2>/dev/null; then
              echo "âœ… MySQL is ready and accepting connections!"
              break
            fi
            
            if [ $i -eq 90 ]; then
              echo "âŒ MySQL failed to start after 3 minutes"
              echo "ğŸ“‹ Container logs (last 100 lines):"
              docker compose -f docker-compose.test.yml logs --tail=100 mysql-test
              echo ""
              echo "ğŸ“Š Container status:"
              docker compose -f docker-compose.test.yml ps
              echo ""
              echo "ğŸ” Testing connection manually:"
              docker compose -f docker-compose.test.yml exec -T mysql-test mysqladmin ping -h localhost -u root -ptestpassword || true
              exit 1
            fi
            
            # Show progress every 10 iterations
            if [ $((i % 10)) -eq 0 ]; then
              echo "Still waiting... ($i/90) - MySQL is initializing..."
            fi
            sleep 2
          done

          # Give MySQL additional time to fully initialize
          echo "â³ Waiting additional 5 seconds for MySQL to fully initialize..."
          sleep 5
          echo "âœ… MySQL is ready!"

      - name: Configure MySQL
        working-directory: ./backend
        run: |
          echo "ğŸ”§ Configuring MySQL settings..."

          # Verify connection first
          echo "Verifying MySQL connection..."
          docker compose -f docker-compose.test.yml exec -T mysql-test mysqladmin ping -h localhost -u root -ptestpassword || {
            echo "âŒ Failed to connect to MySQL"
            docker compose -f docker-compose.test.yml logs --tail=20 mysql-test
            exit 1
          }

          # Configure database settings
          echo "Configuring database character set..."
          docker compose -f docker-compose.test.yml exec -T mysql-test mysql -u root -ptestpassword -e "ALTER DATABASE test_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;" 2>&1 || echo "âš ï¸  Character set configuration skipped (may already be set)"

          # Verify database exists
          echo "Verifying test_db database..."
          docker compose -f docker-compose.test.yml exec -T mysql-test mysql -u root -ptestpassword -e "SHOW DATABASES LIKE 'test_db';" | grep test_db || {
            echo "âŒ test_db database not found!"
            exit 1
          }

          echo "âœ… MySQL configuration completed"

      - name: Run database migrations (test)
        working-directory: ./backend
        run: |
          echo "ğŸ”„ Running database migrations..."
          npm run migrate
          if [ $? -ne 0 ]; then
            echo "âŒ Migration failed!"
            exit 1
          fi
          echo "âœ… Migrations completed successfully"
        env:
          NODE_ENV: test
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: testpassword
          DB_NAME: test_db
          DB_PORT: 3307
          DB_DIALECT: mysql

      - name: Verify migration status (test)
        working-directory: ./backend
        run: |
          echo "ğŸ“Š Checking migration status..."
          npm run migrate:status
          if [ $? -ne 0 ]; then
            echo "âŒ Migration status check failed!"
            exit 1
          fi
          echo "âœ… All migrations are up to date"
        env:
          NODE_ENV: test
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: testpassword
          DB_NAME: test_db
          DB_PORT: 3307
          DB_DIALECT: mysql

      - name: Run unit tests
        working-directory: ./backend
        run: npm run test:unit
        env:
          NODE_ENV: test
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: testpassword
          DB_NAME: test_db
          DB_PORT: 3307
          DB_DIALECT: mysql
          JWT_SECRET: test_jwt_secret

      - name: Run integration tests
        working-directory: ./backend
        run: npm run test:integration
        continue-on-error: true
        env:
          NODE_ENV: test
          DB_HOST: 127.0.0.1
          DB_USER: root
          DB_PASSWORD: testpassword
          DB_NAME: test_db
          DB_PORT: 3307
          DB_DIALECT: mysql
          JWT_SECRET: test_jwt_secret

      - name: Upload test coverage
        uses: codecov/codecov-action@v3
        if: always()
        with:
          files: ./backend/coverage/coverage-final.json
          flags: backend
          name: backend-coverage
        continue-on-error: true

      - name: Stop MySQL test database
        if: always()
        working-directory: ./backend
        run: |
          echo "ğŸ›‘ Stopping MySQL test database..."
          docker compose -f docker-compose.test.yml down -v || true
          echo "âœ… MySQL test database stopped"

  # Linting Job
  lint:
    name: Code Linting
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run ESLint
        working-directory: ./backend
        run: npm run lint

      - name: Check code formatting
        working-directory: ./backend
        run: npm run lint:format
        continue-on-error: true

  # Security Scanning (SCA - Software Composition Analysis)
  security-scan:
    name: Security Vulnerability Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run npm audit
        working-directory: ./backend
        run: npm audit --audit-level=moderate
        continue-on-error: true

      - name: Install Snyk
        continue-on-error: true
        run: npm install -g snyk

      - name: Run Snyk security scan
        continue-on-error: true
        working-directory: ./backend
        run: |
          if [ -n "${{ secrets.SNYK_TOKEN }}" ]; then
            snyk auth ${{ secrets.SNYK_TOKEN }} || true
            snyk test --severity-threshold=high || true
          else
            echo "Snyk token not configured, skipping scan"
          fi
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  # Static Code Analysis (DCA - Dynamic Code Analysis / SAST)
  code-analysis:
    name: Static Code Analysis
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v5.0.0
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          projectBaseDir: ./backend
          args: >
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY || format('{0}_{1}', github.repository_owner, github.event.repository.name) }}
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.sources=.
            -Dsonar.exclusions=**/node_modules/**,**/coverage/**,**/tests/**,**/*.test.js
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v2
        continue-on-error: true
        with:
          languages: javascript
          queries: security-extended,security-and-quality

      - name: Autobuild
        uses: github/codeql-action/autobuild@v2
        continue-on-error: true
        with:
          working-directory: ./backend

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v2
        continue-on-error: true

  # Build Job
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [test, lint, security-scan, code-analysis]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Verify syntax
        working-directory: ./backend
        run: node --check index.js

      - name: Build application
        working-directory: ./backend
        run: npm run build

  # Docker Build Job
  docker-build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify image was pushed
        run: |
          echo "âœ… Image pushed to GHCR:"
          echo "  - ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest"
          echo "  - ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"

  # Deploy to Digital Ocean
  deploy:
    name: Deploy to Digital Ocean
    runs-on: ubuntu-latest
    needs: [docker-build]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    environment:
      name: Production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pull Docker image from GHCR on server
        uses: appleboy/ssh-action@v1.0.0
        env:
          GHCR_TOKEN: ${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          REPO_OWNER: ${{ github.repository_owner }}
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            echo "ğŸ“¦ Pulling Docker image from GHCR..."
            IMAGE_FULL_NAME="${REGISTRY}/${REPO_OWNER}/${IMAGE_NAME}:latest"
            echo "Image: ${IMAGE_FULL_NAME}"

            # Login to GHCR using Personal Access Token
            if [ -n "${GHCR_TOKEN}" ]; then
              echo "${GHCR_TOKEN}" | docker login ${REGISTRY} -u ${REPO_OWNER} --password-stdin
              echo "âœ… Logged in to GHCR"
            else
              echo "âš ï¸  No GHCR token found. Attempting public pull (may fail if package is private)..."
            fi

            # Pull the image
            if docker pull "${IMAGE_FULL_NAME}"; then
              echo "âœ… Image pulled successfully"
            else
              echo "âŒ Failed to pull image. Please ensure:"
              echo "   1. GHCR_PAT secret is set in GitHub Secrets (Production environment)"
              echo "   2. The package permissions allow the token to read"
              echo "   3. The image exists in GHCR: ${IMAGE_FULL_NAME}"
              exit 1
            fi

            # Tag it for local use (docker-compose expects hrms-backend:latest)
            docker tag "${IMAGE_FULL_NAME}" "${IMAGE_NAME}:latest"
            echo "âœ… Docker image pulled and tagged as ${IMAGE_NAME}:latest"
            docker images | grep "${IMAGE_NAME}" || true

      - name: Transfer docker-compose.yml to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          source: "backend/docker-compose.yml"
          target: "/tmp/"
          overwrite: true

      - name: Setup backend directory structure on server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory (with fallbacks)
            BASE_DIR="/opt/hrms"
            if [ ! -d "$BASE_DIR" ]; then
              BASE_DIR="$HOME/hrms"
              if [ ! -d "$BASE_DIR" ]; then
                BASE_DIR="/tmp/hrms"
              fi
              mkdir -p "$BASE_DIR" || {
                echo "âŒ Failed to create directory. Trying with sudo..."
                sudo mkdir -p /opt/hrms || mkdir -p ~/hrms || mkdir -p /tmp/hrms
                BASE_DIR="/opt/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="$HOME/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="/tmp/hrms"
              }
            fi
            # Create backend directory
            mkdir -p "$BASE_DIR/backend" || sudo mkdir -p "$BASE_DIR/backend" || mkdir -p "$HOME/hrms/backend" || mkdir -p "/tmp/hrms/backend"
            # Move docker-compose.yml to backend directory
            if [ -f "/tmp/docker-compose.yml" ]; then
              mv /tmp/docker-compose.yml "$BASE_DIR/backend/docker-compose.yml" || \
                sudo mv /tmp/docker-compose.yml "$BASE_DIR/backend/docker-compose.yml" || \
                mv /tmp/docker-compose.yml "$HOME/hrms/backend/docker-compose.yml" || \
                mv /tmp/docker-compose.yml "/tmp/hrms/backend/docker-compose.yml"
              echo "âœ… docker-compose.yml transferred to $BASE_DIR/backend/"
            else
              echo "âš ï¸  docker-compose.yml not found in /tmp/, will check existing location"
            fi

      - name: Create/Update .env file on server
        uses: appleboy/ssh-action@v1.0.0
        env:
          DB_ROOT_PASSWORD: ${{ secrets.DB_ROOT_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_PORT: ${{ secrets.DB_PORT || '3306' }}
          DB_DIALECT: ${{ secrets.DB_DIALECT || 'mysql' }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM || 'no-reply@kitor.io' }}
          EMAIL_FROM_NAME: ${{ secrets.EMAIL_FROM_NAME || 'Xylobit HRMS' }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          DOMAIN: ${{ secrets.DOMAIN }}
          BACKEND_URL: ${{ secrets.BACKEND_URL }}
          REACT_APP_BACKEND_URL: ${{ secrets.REACT_APP_BACKEND_URL }}
          REACT_APP_FRONTEND_URL: ${{ secrets.REACT_APP_FRONTEND_URL }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET_NAME: ${{ secrets.AWS_S3_BUCKET_NAME }}
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory (with fallbacks)
            BASE_DIR="/opt/hrms"
            if [ ! -d "$BASE_DIR" ]; then
              BASE_DIR="$HOME/hrms"
              if [ ! -d "$BASE_DIR" ]; then
                BASE_DIR="/tmp/hrms"
              fi
              mkdir -p "$BASE_DIR" || {
                echo "âŒ Failed to create directory. Trying with sudo..."
                sudo mkdir -p /opt/hrms || mkdir -p ~/hrms || mkdir -p /tmp/hrms
                BASE_DIR="/opt/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="$HOME/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="/tmp/hrms"
              }
            fi
            cd "$BASE_DIR" || exit 1
            # Create .env file from GitHub Secrets (automated)
            {
              echo "# =========================================="
              echo "# HRMS Application Environment Variables"
              echo "# Auto-generated from GitHub Secrets"
              echo "# =========================================="
              echo ""
              echo "# Application Configuration"
              echo "NODE_ENV=production"
              echo "PORT=8000"
              echo ""
              echo "# Database Configuration"
              echo "DB_ROOT_PASSWORD=${DB_ROOT_PASSWORD}"
              echo "DB_NAME=${DB_NAME}"
              echo "DB_USER=${DB_USER}"
              echo "DB_PASSWORD=${DB_PASSWORD}"
              echo "DB_PORT=${DB_PORT}"
              echo "DB_DIALECT=${DB_DIALECT}"
              echo "DB_HOST=mysql"
              echo ""
              echo "# Security & Authentication"
              echo "JWT_SECRET=${JWT_SECRET}"
              echo ""
              echo "# Email Configuration (SendGrid)"
              echo "SENDGRID_API_KEY=${SENDGRID_API_KEY}"
              echo "EMAIL_FROM=${EMAIL_FROM}"
              echo "EMAIL_FROM_NAME=${EMAIL_FROM_NAME}"
              echo ""
              echo "# URL Configuration"
              echo "FRONTEND_URL=${FRONTEND_URL}"
              echo "DOMAIN=${DOMAIN}"
              echo "BACKEND_URL=${BACKEND_URL}"
              echo ""
              echo "# Frontend Environment Variables (React - for docker-compose)"
              echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL}"
              echo "REACT_APP_FRONTEND_URL=${REACT_APP_FRONTEND_URL}"
              echo ""
              echo "# AWS S3 Configuration (File Storage)"
              echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}"
              echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}"
              echo "AWS_REGION=${AWS_REGION}"
              echo "AWS_S3_BUCKET_NAME=${AWS_S3_BUCKET_NAME}"
            } > "$BASE_DIR/backend/.env"

            # Set secure permissions
            chmod 600 "$BASE_DIR/backend/.env"
            echo ".env file created/updated successfully from GitHub Secrets at $BASE_DIR/backend/.env"

      - name: Deploy to Digital Ocean Droplet
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory (with fallbacks)
            BASE_DIR="/opt/hrms"
            if [ ! -d "$BASE_DIR" ]; then
              BASE_DIR="$HOME/hrms"
              if [ ! -d "$BASE_DIR" ]; then
                BASE_DIR="/tmp/hrms"
              fi
              mkdir -p "$BASE_DIR" || {
                echo "âŒ Failed to create directory. Trying with sudo..."
                sudo mkdir -p /opt/hrms || mkdir -p ~/hrms || mkdir -p /tmp/hrms
                BASE_DIR="/opt/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="$HOME/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="/tmp/hrms"
              }
            fi
            cd "$BASE_DIR" || exit 1

            # Check which docker compose command is available
            DOCKER_COMPOSE_CMD=""
            # Test docker-compose (standalone)
            if command -v docker-compose >/dev/null 2>&1; then
              if docker-compose --version >/dev/null 2>&1; then
                DOCKER_COMPOSE_CMD="docker-compose"
                echo "âœ… Found docker-compose (standalone)"
              fi
            fi
            # Test docker compose (plugin) if standalone not found
            if [ -z "$DOCKER_COMPOSE_CMD" ]; then
              if docker compose version >/dev/null 2>&1; then
                DOCKER_COMPOSE_CMD="docker compose"
                echo "âœ… Found docker compose (plugin)"
              fi
            fi
            # Error if neither is found
            if [ -z "$DOCKER_COMPOSE_CMD" ]; then
              echo "âŒ Error: Neither 'docker-compose' nor 'docker compose' is available."
              echo "Please install Docker Compose:"
              echo "  For plugin version (recommended):"
              echo "    sudo apt-get update && sudo apt-get install docker-compose-plugin"
              echo "  Or for standalone version:"
              echo "    sudo apt-get update && sudo apt-get install docker-compose"
              exit 1
            fi

            # Create shared network if it doesn't exist
            docker network create hrms-network --driver bridge 2>/dev/null || true

            # Ensure backend directory and docker-compose.yml exist
            if [ ! -d "backend" ]; then
              mkdir -p backend
              echo "âš ï¸  Backend directory not found, creating it..."
            fi
            if [ ! -f "backend/docker-compose.yml" ]; then
              echo "âŒ Error: backend/docker-compose.yml not found at $BASE_DIR/backend/"
              echo "Please ensure the docker-compose.yml file is present in the backend directory."
              exit 1
            fi

            # Start services (database will start first due to depends_on)
            # Note: Backend image is already pulled from GHCR and tagged as hrms-backend:latest, MySQL image will be pulled if needed
            cd backend

            # Export environment variables for docker-compose (from .env file)
            set -a
            source "$BASE_DIR/backend/.env"
            set +a

            $DOCKER_COMPOSE_CMD up -d mysql
            sleep 10
            # Use the loaded image instead of pulling
            $DOCKER_COMPOSE_CMD up -d --no-deps backend
            # Wait for backend to be ready
            echo "Waiting for backend container to be ready..."
            sleep 15
            # Run migrations with automatic rollback on failure
            echo "ğŸ”„ Running database migrations (with auto-rollback on failure)..."
            # Capture migration state before running migrations
            echo "ğŸ“Š Capturing migration state before migration..."
            MIGRATION_STATE_BEFORE=$($DOCKER_COMPOSE_CMD exec -T backend npm run migrate:status 2>&1 || echo "")
            echo "$MIGRATION_STATE_BEFORE"
            # Run migrations using safe migration script (with automatic rollback)
            echo "ğŸš€ Starting safe migration process..."
            if $DOCKER_COMPOSE_CMD exec -T backend npm run migrate:safe; then
              echo "âœ… Migrations completed successfully"
              # Verify final migration status
              echo "ğŸ“Š Verifying final migration status..."
              $DOCKER_COMPOSE_CMD exec -T backend npm run migrate:status
              echo "âœ… All migrations verified and database is in correct state"
            else
              echo "âŒ Migration failed! Rollback was attempted automatically."
              echo "ğŸ“‹ Showing backend logs for debugging..."
              $DOCKER_COMPOSE_CMD logs --tail=50 backend
              echo ""
              echo "ğŸ“Š Current migration status after rollback:"
              $DOCKER_COMPOSE_CMD exec -T backend npm run migrate:status || true
              echo ""
              echo "âŒ Deployment stopped due to migration failure."
              echo "ğŸ“‹ Database has been rolled back to previous state."
              echo "ğŸ“‹ Please fix migration issues and try again."
              exit 1
            fi
            # Clean up unused images
            docker system prune -f

      - name: Health Check
        run: |
          sleep 10
          curl -f ${{ secrets.DEPLOY_URL }}/api/health || exit 1
