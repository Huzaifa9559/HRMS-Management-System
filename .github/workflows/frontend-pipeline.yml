name: Frontend CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
    paths:
      - "frontend/**"
  pull_request:
    branches:
      - main
      - develop
    paths:
      - "frontend/**"
  workflow_dispatch:

env:
  NODE_VERSION: "18"
  IMAGE_NAME: hrms-frontend

jobs:
  # Testing Job
  test:
    name: Unit & E2E Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run unit tests
        working-directory: ./frontend
        run: npm run test:unit -- --coverage --watchAll=false
        env:
          CI: true
          REACT_APP_BACKEND_URL: http://localhost:8000

      - name: Upload test coverage
        uses: codecov/codecov-action@v3
        if: always()
        with:
          files: ./frontend/coverage/coverage-final.json
          flags: frontend
          name: frontend-coverage
        continue-on-error: true

      - name: Start frontend application
        working-directory: ./frontend
        run: |
          BROWSER=none npm start > /dev/null 2>&1 &
          echo $! > .react-server.pid
        env:
          CI: true
          REACT_APP_BACKEND_URL: http://localhost:8000
          PORT: 3000

      - name: Wait for frontend to be ready
        run: |
          echo "Waiting for frontend to start..."
          n=0
          until curl -f http://localhost:3000 > /dev/null 2>&1 || [ $n -ge 60 ]; do
            sleep 2
            n=$((n+1))
          done
          if [ $n -ge 60 ]; then
            echo "Frontend failed to start"
            exit 1
          fi
          echo "Frontend is ready!"

      - name: Run E2E tests with Cypress
        working-directory: ./frontend
        run: npm run test:e2e
        continue-on-error: true
        env:
          CI: true
          CYPRESS_baseUrl: http://localhost:3000
          REACT_APP_BACKEND_URL: http://localhost:8000

      - name: Upload Cypress screenshots
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: cypress-screenshots
          path: frontend/cypress/screenshots
          retention-days: 7

      - name: Upload Cypress videos
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: cypress-videos
          path: frontend/cypress/videos
          retention-days: 7

      - name: Stop frontend application
        if: always()
        working-directory: ./frontend
        run: |
          if [ -f .react-server.pid ]; then
            kill $(cat .react-server.pid) 2>/dev/null || true
            rm -f .react-server.pid
          fi
          pkill -f "react-scripts start" || true

  # Linting Job
  lint:
    name: Code Linting
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run ESLint
        working-directory: ./frontend
        run: npm run lint

      - name: Check code formatting
        working-directory: ./frontend
        run: npm run lint:format
        continue-on-error: true

  # Security Scanning (SCA)
  security-scan:
    name: Security Vulnerability Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run npm audit
        working-directory: ./frontend
        run: npm audit --audit-level=moderate
        continue-on-error: true

      - name: Install Snyk
        continue-on-error: true
        run: npm install -g snyk

      - name: Run Snyk security scan
        continue-on-error: true
        working-directory: ./frontend
        run: |
          if [ -n "${{ secrets.SNYK_TOKEN }}" ]; then
            snyk auth ${{ secrets.SNYK_TOKEN }} || true
            snyk test --severity-threshold=high || true
          else
            echo "Snyk token not configured, skipping scan"
          fi
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  # Static Code Analysis
  code-analysis:
    name: Static Code Analysis
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Run CodeQL Analysis
        uses: github/codeql-action/analyze@v2
        continue-on-error: true

  # Build Job
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [test, lint, security-scan, code-analysis]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Build application
        working-directory: ./frontend
        run: npm run build
        env:
          REACT_APP_BACKEND_URL: ${{ secrets.REACT_APP_BACKEND_URL || 'http://localhost:8000' }}
          REACT_APP_FRONTEND_URL: ${{ secrets.REACT_APP_FRONTEND_URL || '' }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/build
          retention-days: 7

  # Docker Build Job
  docker-build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: false
          tags: ${{ env.IMAGE_NAME }}:latest
          build-args: |
            REACT_APP_BACKEND_URL=${{ secrets.REACT_APP_BACKEND_URL }}
            REACT_APP_FRONTEND_URL=${{ secrets.REACT_APP_FRONTEND_URL }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Save Docker image as tar
        run: |
          docker save ${{ env.IMAGE_NAME }}:latest | gzip > /tmp/${{ env.IMAGE_NAME }}.tar.gz
          ls -lh /tmp/${{ env.IMAGE_NAME }}.tar.gz

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-docker-image
          path: /tmp/${{ env.IMAGE_NAME }}.tar.gz
          retention-days: 1

  # Deploy to Digital Ocean
  deploy:
    name: Deploy to Digital Ocean
    runs-on: ubuntu-latest
    needs: [docker-build]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    environment:
      name: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-docker-image
          path: /tmp/

      - name: Transfer Docker image to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          source: "/tmp/frontend-docker-image/*.tar.gz"
          target: "/tmp/"
          strip_components: 1

      - name: Load Docker image on server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            echo "üì¶ Loading Docker image..."
            gunzip -c /tmp/${{ env.IMAGE_NAME }}.tar.gz | docker load
            echo "‚úÖ Docker image loaded successfully"
            docker images | grep ${{ env.IMAGE_NAME }} || true
            rm -f /tmp/${{ env.IMAGE_NAME }}.tar.gz

      - name: Create/Update .env file on server
        uses: appleboy/ssh-action@v1.0.0
        env:
          DB_ROOT_PASSWORD: ${{ secrets.DB_ROOT_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_PORT: ${{ secrets.DB_PORT || '3306' }}
          DB_DIALECT: ${{ secrets.DB_DIALECT || 'mysql' }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM || 'no-reply@kitor.io' }}
          EMAIL_FROM_NAME: ${{ secrets.EMAIL_FROM_NAME || 'Xylobit HRMS' }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          DOMAIN: ${{ secrets.DOMAIN }}
          BACKEND_URL: ${{ secrets.BACKEND_URL }}
          REACT_APP_BACKEND_URL: ${{ secrets.REACT_APP_BACKEND_URL }}
          REACT_APP_FRONTEND_URL: ${{ secrets.REACT_APP_FRONTEND_URL }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET_NAME: ${{ secrets.AWS_S3_BUCKET_NAME }}
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            cd /opt/hrms
            # Create .env file from GitHub Secrets (automated)
            {
              echo "# =========================================="
              echo "# HRMS Application Environment Variables"
              echo "# Auto-generated from GitHub Secrets"
              echo "# =========================================="
              echo ""
              echo "# Application Configuration"
              echo "NODE_ENV=production"
              echo ""
              echo "# Database Configuration"
              echo "DB_ROOT_PASSWORD=${DB_ROOT_PASSWORD}"
              echo "DB_NAME=${DB_NAME}"
              echo "DB_USER=${DB_USER}"
              echo "DB_PASSWORD=${DB_PASSWORD}"
              echo "DB_PORT=${DB_PORT}"
              echo "DB_DIALECT=${DB_DIALECT}"
              echo ""
              echo "# Security & Authentication"
              echo "JWT_SECRET=${JWT_SECRET}"
              echo ""
              echo "# Email Configuration (SendGrid)"
              echo "SENDGRID_API_KEY=${SENDGRID_API_KEY}"
              echo "EMAIL_FROM=${EMAIL_FROM}"
              echo "EMAIL_FROM_NAME=${EMAIL_FROM_NAME}"
              echo ""
              echo "# URL Configuration"
              echo "FRONTEND_URL=${FRONTEND_URL}"
              echo "DOMAIN=${DOMAIN}"
              echo "BACKEND_URL=${BACKEND_URL}"
              echo ""
              echo "# Frontend Environment Variables (React - for docker-compose)"
              echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL}"
              echo "REACT_APP_FRONTEND_URL=${REACT_APP_FRONTEND_URL}"
              echo ""
              echo "# AWS S3 Configuration (File Storage)"
              echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}"
              echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}"
              echo "AWS_REGION=${AWS_REGION}"
              echo "AWS_S3_BUCKET_NAME=${AWS_S3_BUCKET_NAME}"
            } > .env
            # Set secure permissions
            chmod 600 .env
            echo ".env file created/updated successfully from GitHub Secrets"

      - name: Deploy to Digital Ocean Droplet
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            cd /opt/hrms
            # Create shared network if it doesn't exist
            docker network create hrms-network --driver bridge 2>/dev/null || true
            # Use the loaded image instead of pulling
            docker-compose up -d --no-deps frontend
            # Clean up unused images
            docker system prune -f

      - name: Copy Nginx files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          source: "nginx/*"
          target: "/opt/hrms/nginx/"

      - name: Deploy Nginx Reverse Proxy
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            echo "üîß Setting up Nginx reverse proxy..."
            
            # Ensure nginx directory exists
            mkdir -p /opt/hrms/nginx
            cd /opt/hrms/nginx
            
            # Update container ports to bind to localhost (if not already done)
            cd /opt/hrms/backend
            if grep -q '"8000:8000"' docker-compose.yml 2>/dev/null; then
              sed -i 's/"8000:8000"/"127.0.0.1:8000:8000"/' docker-compose.yml
              docker-compose restart backend || true
              echo "‚úÖ Backend ports updated to localhost"
            fi
            
            cd /opt/hrms/frontend
            if grep -q '"80:80"' docker-compose.yml 2>/dev/null; then
              sed -i 's/"80:80"/"127.0.0.1:80:80"/' docker-compose.yml
              docker-compose restart frontend || true
              echo "‚úÖ Frontend ports updated to localhost"
            fi
            
            # Copy nginx files if they don't exist (from repo)
            cd /opt/hrms/nginx
            if [ ! -f "docker-compose.yml" ]; then
              echo "‚ö†Ô∏è  Nginx files not found. Please ensure nginx/ directory exists in repo."
              echo "   For now, skipping nginx deployment."
              exit 0
            fi
            
            # Create certbot directories
            mkdir -p certbot/conf certbot/www
            
            # Ensure network exists
            docker network create hrms-network --driver bridge 2>/dev/null || true
            
            # Check if SSL certificates exist
            if [ -f "certbot/conf/live/h-rms.me/fullchain.pem" ]; then
              echo "‚úÖ SSL certificates found, using SSL config"
              # Ensure we have the full nginx.conf with SSL
              if [ ! -f "nginx.conf" ] || ! grep -q "ssl_certificate" nginx.conf 2>/dev/null; then
                echo "‚ö†Ô∏è  nginx.conf missing SSL config, using initial config"
                if [ -f "nginx.conf.initial" ]; then
                  cp nginx.conf.initial nginx.conf
                fi
              fi
            else
              echo "‚ö†Ô∏è  SSL certificates not found, using HTTP-only config"
              if [ -f "nginx.conf.initial" ]; then
                cp nginx.conf.initial nginx.conf
              fi
            fi
            
            # Start/restart nginx
            echo "üöÄ Starting Nginx reverse proxy..."
            docker-compose up -d nginx
            
            # Wait and verify
            sleep 5
            if docker ps | grep -q hrms-nginx; then
              echo "‚úÖ Nginx reverse proxy is running"
              docker exec hrms-nginx nginx -t && echo "‚úÖ Nginx config is valid"
            else
              echo "‚ö†Ô∏è  Nginx container may not be running. Check logs:"
              docker logs hrms-nginx || true
            fi

      - name: Health Check
        run: |
          sleep 10
          curl -f ${{ secrets.FRONTEND_DEPLOY_URL }}/health || exit 1
