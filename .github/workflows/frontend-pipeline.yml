name: Frontend CI/CD Pipeline


on:
  push:
    branches:
      - main
    paths:
      - "frontend/**"
      - ".github/workflows/frontend-pipeline.yml"
  pull_request:
    branches:
      - main
    paths:
      - "frontend/**"
      - ".github/workflows/frontend-pipeline.yml"
  workflow_dispatch:

env:
  NODE_VERSION: "18"
  IMAGE_NAME: hrms-frontend
  REGISTRY: ghcr.io
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Testing Job
  test:
    name: Unit & E2E Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run unit tests
        working-directory: ./frontend
        run: npm run test:unit -- --coverage --watchAll=false
        env:
          CI: true
          REACT_APP_BACKEND_URL: http://localhost:8000

      - name: Upload test coverage
        uses: codecov/codecov-action@v3
        if: always()
        with:
          files: ./frontend/coverage/coverage-final.json
          flags: frontend
          name: frontend-coverage
        continue-on-error: true

      # - name: Upload coverage artifact for SonarCloud
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: frontend-coverage
      #     path: frontend/coverage


      - name: Build frontend application
        working-directory: ./frontend
        run: npm run build
        env:
          CI: true
          REACT_APP_BACKEND_URL: http://localhost:8000

      - name: Install serve package
        run: npm install -g serve

      - name: Start frontend application (production build)
        working-directory: ./frontend
        run: |
          serve -s build -l 3000 > /dev/null 2>&1 &
          echo $! > .react-server.pid
          sleep 3

      - name: Wait for frontend to be ready
        run: |
          echo "Waiting for frontend to start..."
          n=0
          until curl -f http://localhost:3000 > /dev/null 2>&1 || [ $n -ge 30 ]; do
            sleep 1
            n=$((n+1))
          done
          if [ $n -ge 30 ]; then
            echo "Frontend failed to start"
            exit 1
          fi
          echo "Frontend is ready!"

      - name: Run E2E tests with Cypress
        working-directory: ./frontend
        run: npm run test:e2e
        continue-on-error: true
        env:
          CI: true
          CYPRESS_baseUrl: http://localhost:3000
          REACT_APP_BACKEND_URL: http://localhost:8000

      - name: Upload Cypress screenshots
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: cypress-screenshots
          path: frontend/cypress/screenshots
          retention-days: 7

      - name: Upload Cypress videos
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: cypress-videos
          path: frontend/cypress/videos
          retention-days: 7

      - name: Stop frontend application
        if: always()
        working-directory: ./frontend
        run: |
          if [ -f .react-server.pid ]; then
            kill $(cat .react-server.pid) 2>/dev/null || true
            rm -f .react-server.pid
          fi
          pkill -f "serve -s build" || true

  # Linting Job
  lint:
    name: Code Linting
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run ESLint
        working-directory: ./frontend
        run: npm run lint

      - name: Check code formatting
        working-directory: ./frontend
        run: npm run lint:format
        continue-on-error: true

  # Security Scanning (SCA - Software Composition Analysis)
  security-scan:
    name: Security Vulnerability Scan
    runs-on: ubuntu-latest
    env:
      SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      # If your Snyk org is on eu.snyk.io, uncomment this:
      # SNYK_API: https://api.eu.snyk.io

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Sanity check that the token is really available to this job
      - name: Debug SNYK token presence
        run: |
          if [ -z "${SNYK_TOKEN}" ]; then
            echo "âŒ SNYK_TOKEN is empty or not set"
            exit 1
          else
            echo "âœ… SNYK_TOKEN is set (length: ${#SNYK_TOKEN})"
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      # Optional light scan with npm audit
      - name: Run npm audit
        working-directory: ./frontend
        run: npm audit --audit-level=moderate || true

      - name: Install Snyk CLI
        run: npm install -g snyk

      # Main Snyk dependency scan
      - name: Run Snyk test (dependencies)
        working-directory: ./frontend
        run: snyk test --severity-threshold=high || true

      # Optional: push a snapshot to Snyk UI dashboard
      - name: Monitor project in Snyk
        working-directory: ./frontend
        run: snyk monitor || true

  # Static Code Analysis
  code-analysis:
    name: Static Code Analysis
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for SonarCloud to properly detect branch information

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci


      #
      #keep or no?
      # - name: Run tests with coverage
      #   working-directory: ./frontend
      #   run: npm run test -- --coverage --watchAll=false
      #   env:
      #     CI: true
      #     REACT_APP_BACKEND_URL: http://localhost:8000
      #   continue-on-error: true
      
      #download previously uploaded artifact
      # - name: Download coverage artifact
      #   uses: actions/download-artifact@v4
      #   with:
      #     name: frontend-coverage
      #     path: frontend/coverage


      - name: Run SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v6
        with:
          projectBaseDir: ./frontend
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN_FRONTEND }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

  # Build Job
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [test, lint, security-scan, code-analysis]
    environment:
      name: Production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Build application
        working-directory: ./frontend
        run: npm run build
        env:
          REACT_APP_BACKEND_URL: ${{ secrets.REACT_APP_BACKEND_URL || 'http://localhost:8000' }}
          REACT_APP_FRONTEND_URL: ${{ secrets.REACT_APP_FRONTEND_URL || '' }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/build
          retention-days: 7

  # Docker Build Job
  docker-build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    environment:
      name: Production
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            REACT_APP_BACKEND_URL=${{ secrets.REACT_APP_BACKEND_URL }}
            REACT_APP_FRONTEND_URL=${{ secrets.REACT_APP_FRONTEND_URL }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify image was pushed
        run: |
          echo "âœ… Image pushed to GHCR:"
          echo "  - ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest"
          echo "  - ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"

  # Deploy to Digital Ocean
  deploy:
    name: Deploy to Digital Ocean
    runs-on: ubuntu-latest
    needs: [docker-build]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    environment:
      name: Production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pull Docker image from GHCR on server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            echo "ğŸ“¦ Pulling Docker image from GHCR..."
            REGISTRY="ghcr.io"
            REPO_OWNER_ORIGINAL="${{ github.repository_owner }}"
            REPO_OWNER_LOWER=$(echo "${REPO_OWNER_ORIGINAL}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="hrms-frontend"
            IMAGE_FULL_NAME="${REGISTRY}/${REPO_OWNER_LOWER}/${IMAGE_NAME}:latest"
            echo "Image: ${IMAGE_FULL_NAME}"

            # Login to GHCR using Personal Access Token
            # Note: Login username should match GitHub username (case-sensitive for auth)
            GHCR_TOKEN="${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}"
            if [ -n "${GHCR_TOKEN}" ] && [ "${GHCR_TOKEN}" != "" ]; then
              echo "${GHCR_TOKEN}" | docker login ${REGISTRY} -u ${REPO_OWNER_ORIGINAL} --password-stdin
              echo "âœ… Logged in to GHCR"
            else
              echo "âš ï¸  No GHCR token found. Attempting public pull (may fail if package is private)..."
              echo "   Please ensure GHCR_PAT secret is set in GitHub Secrets (Production environment)"
            fi

            # Pull the image
            if docker pull "${IMAGE_FULL_NAME}"; then
              echo "âœ… Image pulled successfully"
            else
              echo "âŒ Failed to pull image. Please ensure:"
              echo "   1. GHCR_PAT secret is set in GitHub Secrets (Production environment)"
              echo "   2. The package permissions allow the token to read"
              echo "   3. The image exists in GHCR: ${IMAGE_FULL_NAME}"
              exit 1
            fi

            # Tag it for local use (docker-compose expects hrms-frontend:latest)
            docker tag "${IMAGE_FULL_NAME}" "${IMAGE_NAME}:latest"
            echo "âœ… Docker image pulled and tagged as ${IMAGE_NAME}:latest"
            docker images | grep "${IMAGE_NAME}" || true

      - name: Create/Update .env file on server
        uses: appleboy/ssh-action@v1.0.0
        env:
          DB_ROOT_PASSWORD: ${{ secrets.DB_ROOT_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_PORT: ${{ secrets.DB_PORT || '3306' }}
          DB_DIALECT: ${{ secrets.DB_DIALECT || 'mysql' }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM || 'no-reply@kitor.io' }}
          EMAIL_FROM_NAME: ${{ secrets.EMAIL_FROM_NAME || 'Xylobit HRMS' }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          DOMAIN: ${{ secrets.DOMAIN }}
          BACKEND_URL: ${{ secrets.BACKEND_URL }}
          REACT_APP_BACKEND_URL: ${{ secrets.REACT_APP_BACKEND_URL }}
          REACT_APP_FRONTEND_URL: ${{ secrets.REACT_APP_FRONTEND_URL }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET_NAME: ${{ secrets.AWS_S3_BUCKET_NAME }}
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          envs: DB_ROOT_PASSWORD,DB_NAME,DB_USER,DB_PASSWORD,DB_PORT,DB_DIALECT,JWT_SECRET,SENDGRID_API_KEY,EMAIL_FROM,EMAIL_FROM_NAME,FRONTEND_URL,DOMAIN,BACKEND_URL,REACT_APP_BACKEND_URL,REACT_APP_FRONTEND_URL,AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,AWS_REGION,AWS_S3_BUCKET_NAME
          script: |
            # Determine the base directory
            BASE_DIR="/home/huzaifa/hrms"
            mkdir -p "$BASE_DIR/frontend" || {
              echo "âŒ Failed to create directory: $BASE_DIR/frontend"
              exit 1
            }
            cd "$BASE_DIR" || exit 1

            # Helper to safely write env values (handles spaces/special chars)
            write_env() {
              key="$1"
              value="$2"
              needs_quoting=false

              case "$value" in
                *[!A-Za-z0-9._-]*)
                  needs_quoting=true
                  ;;
              esac

              if [ "$needs_quoting" = true ]; then
                escaped_value=$(printf '%s' "$value" | sed 's/\\/\\\\/g; s/"/\\"/g; s/\$/\\$/g; s/`/\\`/g')
                echo "${key}=\"${escaped_value}\"" >> "$BASE_DIR/frontend/.env"
              else
                echo "${key}=${value}" >> "$BASE_DIR/frontend/.env"
              fi
            }

            # Create .env file from GitHub Secrets (automated)
            ENV_FILE="$BASE_DIR/frontend/.env"
            : > "$ENV_FILE"

            {
              echo "# =========================================="
              echo "# HRMS Application Environment Variables"
              echo "# Auto-generated from GitHub Secrets"
              echo "# =========================================="
              echo ""
              echo "# Application Configuration"
            } >> "$ENV_FILE"
            write_env "NODE_ENV" "production"
            echo "" >> "$ENV_FILE"

            {
              echo "# Database Configuration"
            } >> "$ENV_FILE"
            write_env "DB_ROOT_PASSWORD" "${DB_ROOT_PASSWORD}"
            write_env "DB_NAME" "${DB_NAME}"
            write_env "DB_USER" "${DB_USER}"
            write_env "DB_PASSWORD" "${DB_PASSWORD}"
            write_env "DB_PORT" "${DB_PORT}"
            write_env "DB_DIALECT" "${DB_DIALECT}"
            echo "" >> "$ENV_FILE"

            {
              echo "# Security & Authentication"
            } >> "$ENV_FILE"
            write_env "JWT_SECRET" "${JWT_SECRET}"
            echo "" >> "$ENV_FILE"

            {
              echo "# Email Configuration (SendGrid)"
            } >> "$ENV_FILE"
            write_env "SENDGRID_API_KEY" "${SENDGRID_API_KEY}"
            write_env "EMAIL_FROM" "${EMAIL_FROM}"
            write_env "EMAIL_FROM_NAME" "${EMAIL_FROM_NAME}"
            echo "" >> "$ENV_FILE"

            {
              echo "# URL Configuration"
            } >> "$ENV_FILE"
            write_env "FRONTEND_URL" "${FRONTEND_URL}"
            write_env "DOMAIN" "${DOMAIN}"
            write_env "BACKEND_URL" "${BACKEND_URL}"
            echo "" >> "$ENV_FILE"

            {
              echo "# Frontend Environment Variables (React - for docker-compose)"
            } >> "$ENV_FILE"
            write_env "REACT_APP_BACKEND_URL" "${REACT_APP_BACKEND_URL}"
            write_env "REACT_APP_FRONTEND_URL" "${REACT_APP_FRONTEND_URL}"
            echo "" >> "$ENV_FILE"

            {
              echo "# AWS S3 Configuration (File Storage)"
            } >> "$ENV_FILE"
            write_env "AWS_ACCESS_KEY_ID" "${AWS_ACCESS_KEY_ID}"
            write_env "AWS_SECRET_ACCESS_KEY" "${AWS_SECRET_ACCESS_KEY}"
            write_env "AWS_REGION" "${AWS_REGION}"
            write_env "AWS_S3_BUCKET_NAME" "${AWS_S3_BUCKET_NAME}"

            # Set secure permissions
            chmod 600 "$BASE_DIR/frontend/.env"
            echo ".env file created/updated successfully from GitHub Secrets at $BASE_DIR/frontend/.env"

      - name: Encode frontend docker-compose file
        id: encode_frontend_compose
        run: |
          FRONTEND_COMPOSE_B64=$(base64 -w 0 frontend/docker-compose.yml)
          echo "frontend_compose_b64=$FRONTEND_COMPOSE_B64" >> $GITHUB_OUTPUT
          echo "âœ… Frontend docker-compose.yml encoded"

      - name: Write frontend docker-compose.yml to server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory
            BASE_DIR="/home/huzaifa/hrms"
            mkdir -p "$BASE_DIR/frontend" || {
              echo "âŒ Failed to create directory: $BASE_DIR/frontend"
              exit 1
            }

            # Decode and write docker-compose.yml
            echo "${{ steps.encode_frontend_compose.outputs.frontend_compose_b64 }}" | base64 -d > $BASE_DIR/frontend/docker-compose.yml

            # Set permissions
            chmod 644 $BASE_DIR/frontend/docker-compose.yml 2>/dev/null || sudo chmod 644 $BASE_DIR/frontend/docker-compose.yml || true

            # Verify file
            echo "âœ… Frontend docker-compose.yml written to: $BASE_DIR/frontend/"
            ls -la $BASE_DIR/frontend/docker-compose.yml || ls -la ~/hrms/frontend/docker-compose.yml || ls -la /tmp/hrms/frontend/docker-compose.yml

      - name: Deploy to Digital Ocean Droplet
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory
            BASE_DIR="/home/huzaifa/hrms"
            mkdir -p "$BASE_DIR" || {
              echo "âŒ Failed to create directory: $BASE_DIR"
              exit 1
            }
            cd "$BASE_DIR" || exit 1

            # Check which docker compose command is available
            DOCKER_COMPOSE_CMD=""
            # Test docker-compose (standalone)
            if command -v docker-compose >/dev/null 2>&1; then
              if docker-compose --version >/dev/null 2>&1; then
                DOCKER_COMPOSE_CMD="docker-compose"
                echo "âœ… Found docker-compose (standalone)"
              fi
            fi
            # Test docker compose (plugin) if standalone not found
            if [ -z "$DOCKER_COMPOSE_CMD" ]; then
              if docker compose version >/dev/null 2>&1; then
                DOCKER_COMPOSE_CMD="docker compose"
                echo "âœ… Found docker compose (plugin)"
              fi
            fi
            # Error if neither is found
            if [ -z "$DOCKER_COMPOSE_CMD" ]; then
              echo "âŒ Error: Neither 'docker-compose' nor 'docker compose' is available."
              echo "Please install Docker Compose:"
              echo "  For plugin version (recommended):"
              echo "    sudo apt-get update && sudo apt-get install docker-compose-plugin"
              echo "  Or for standalone version:"
              echo "    sudo apt-get update && sudo apt-get install docker-compose"
              exit 1
            fi

            # Create shared network if it doesn't exist
            docker network create hrms-network --driver bridge 2>/dev/null || true

            # Ensure frontend directory and docker-compose.yml exist
            if [ ! -d "frontend" ]; then
              mkdir -p frontend
              echo "âš ï¸  Frontend directory not found, creating it..."
            fi
            if [ ! -f "frontend/docker-compose.yml" ]; then
              echo "âŒ Error: frontend/docker-compose.yml not found at $BASE_DIR/frontend/"
              echo "Please ensure the docker-compose.yml file is present in the frontend directory."
              exit 1
            fi

            # Start frontend service
            cd frontend

            # Export environment variables for docker-compose (from .env file)
            set -a
            source "$BASE_DIR/frontend/.env"
            set +a

            # Use the pulled image (already tagged as hrms-frontend:latest)
            $DOCKER_COMPOSE_CMD up -d --no-deps frontend

            # Clean up unused Docker resources
            echo "ğŸ§¹ Cleaning up unused Docker resources..."

            # Show disk usage before cleanup
            echo "ğŸ“Š Disk usage before cleanup:"
            docker system df

            # Remove stopped containers
            echo "ğŸ—‘ï¸  Removing stopped containers..."
            docker container prune -f

            # Remove unused images (but keep images that are in use)
            echo "ğŸ—‘ï¸  Removing unused images..."
            docker image prune -af --filter "until=24h" || docker image prune -af

            # Remove unused volumes (but keep named volumes)
            echo "ğŸ—‘ï¸  Removing unused volumes..."
            docker volume prune -f

            # Remove unused networks (but keep hrms-network)
            echo "ğŸ—‘ï¸  Removing unused networks..."
            docker network prune -f

            # Show disk usage after cleanup
            echo "ğŸ“Š Disk usage after cleanup:"
            docker system df

            echo "âœ… Docker cleanup completed"

      # Note: Nginx deployment is handled by the dedicated nginx-deploy.yml workflow
      # which runs after frontend/backend pipelines complete. No need to deploy nginx here.

      # - name: Health Check
      #   run: |
      #     sleep 10
      #     curl -f ${{ secrets.FRONTEND_DEPLOY_URL }}/health || exit 1
