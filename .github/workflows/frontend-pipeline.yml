name: Frontend CI/CD Pipeline

on:
  push:
    branches:
      - main
    paths:
      - "frontend/**"
      - ".github/workflows/frontend-pipeline.yml"
  pull_request:
    branches:
      - main
    paths:
      - "frontend/**"
      - ".github/workflows/frontend-pipeline.yml"
  workflow_dispatch:

    
env:
  NODE_VERSION: "18"
  IMAGE_NAME: hrms-frontend
  REGISTRY: ghcr.io
  IMAGE_TAG: ${{ github.sha }}

jobs:
  # Testing Job
  test:
    name: Unit & E2E Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run unit tests
        working-directory: ./frontend
        run: npm run test:unit -- --coverage --watchAll=false
        env:
          CI: true
          REACT_APP_BACKEND_URL: http://localhost:8000

      - name: Upload test coverage
        uses: codecov/codecov-action@v3
        if: always()
        with:
          files: ./frontend/coverage/coverage-final.json
          flags: frontend
          name: frontend-coverage
        continue-on-error: true

      - name: Build frontend application
        working-directory: ./frontend
        run: npm run build
        env:
          CI: true
          REACT_APP_BACKEND_URL: http://localhost:8000

      - name: Install serve package
        run: npm install -g serve

      - name: Start frontend application (production build)
        working-directory: ./frontend
        run: |
          serve -s build -l 3000 > /dev/null 2>&1 &
          echo $! > .react-server.pid
          sleep 3

      - name: Wait for frontend to be ready
        run: |
          echo "Waiting for frontend to start..."
          n=0
          until curl -f http://localhost:3000 > /dev/null 2>&1 || [ $n -ge 30 ]; do
            sleep 1
            n=$((n+1))
          done
          if [ $n -ge 30 ]; then
            echo "Frontend failed to start"
            exit 1
          fi
          echo "Frontend is ready!"

      - name: Run E2E tests with Cypress
        working-directory: ./frontend
        run: npm run test:e2e
        continue-on-error: true
        env:
          CI: true
          CYPRESS_baseUrl: http://localhost:3000
          REACT_APP_BACKEND_URL: http://localhost:8000

      - name: Upload Cypress screenshots
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: cypress-screenshots
          path: frontend/cypress/screenshots
          retention-days: 7

      - name: Upload Cypress videos
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: cypress-videos
          path: frontend/cypress/videos
          retention-days: 7

      - name: Stop frontend application
        if: always()
        working-directory: ./frontend
        run: |
          if [ -f .react-server.pid ]; then
            kill $(cat .react-server.pid) 2>/dev/null || true
            rm -f .react-server.pid
          fi
          pkill -f "serve -s build" || true

  # Linting Job
  lint:
    name: Code Linting
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run ESLint
        working-directory: ./frontend
        run: npm run lint

      - name: Check code formatting
        working-directory: ./frontend
        run: npm run lint:format
        continue-on-error: true

  # Security Scanning (SCA)
  security-scan:
    name: Security Vulnerability Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run npm audit
        working-directory: ./frontend
        run: npm audit --audit-level=moderate
        continue-on-error: true

      - name: Install Snyk
        continue-on-error: true
        run: npm install -g snyk

      - name: Run Snyk security scan
        continue-on-error: true
        working-directory: ./frontend
        run: |
          if [ -n "${{ secrets.SNYK_TOKEN }}" ]; then
            snyk auth ${{ secrets.SNYK_TOKEN }} || true
            snyk test --severity-threshold=high || true
          else
            echo "Snyk token not configured, skipping scan"
          fi
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

  # Static Code Analysis
  code-analysis:
    name: Static Code Analysis
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      - name: Run CodeQL Analysis
        uses: github/codeql-action/analyze@v2
        continue-on-error: true

  # Build Job
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [test, lint, security-scan, code-analysis]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Build application
        working-directory: ./frontend
        run: npm run build
        env:
          REACT_APP_BACKEND_URL: ${{ secrets.REACT_APP_BACKEND_URL || 'http://localhost:8000' }}
          REACT_APP_FRONTEND_URL: ${{ secrets.REACT_APP_FRONTEND_URL || '' }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/build
          retention-days: 7

  # Docker Build Job
  docker-build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image to GHCR
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            REACT_APP_BACKEND_URL=${{ secrets.REACT_APP_BACKEND_URL }}
            REACT_APP_FRONTEND_URL=${{ secrets.REACT_APP_FRONTEND_URL }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify image was pushed
        run: |
          echo "‚úÖ Image pushed to GHCR:"
          echo "  - ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:latest"
          echo "  - ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"

  # Deploy to Digital Ocean
  deploy:
    name: Deploy to Digital Ocean
    runs-on: ubuntu-latest
    needs: [docker-build]
    if: github.ref == 'refs/heads/main' && github.event_name != 'pull_request'
    environment:
      name: Production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Pull Docker image from GHCR on server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            echo "üì¶ Pulling Docker image from GHCR..."
            REGISTRY="ghcr.io"
            REPO_OWNER_ORIGINAL="${{ github.repository_owner }}"
            REPO_OWNER_LOWER=$(echo "${REPO_OWNER_ORIGINAL}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="hrms-frontend"
            IMAGE_FULL_NAME="${REGISTRY}/${REPO_OWNER_LOWER}/${IMAGE_NAME}:latest"
            echo "Image: ${IMAGE_FULL_NAME}"

            # Login to GHCR using Personal Access Token
            # Note: Login username should match GitHub username (case-sensitive for auth)
            GHCR_TOKEN="${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}"
            if [ -n "${GHCR_TOKEN}" ] && [ "${GHCR_TOKEN}" != "" ]; then
              echo "${GHCR_TOKEN}" | docker login ${REGISTRY} -u ${REPO_OWNER_ORIGINAL} --password-stdin
              echo "‚úÖ Logged in to GHCR"
            else
              echo "‚ö†Ô∏è  No GHCR token found. Attempting public pull (may fail if package is private)..."
              echo "   Please ensure GHCR_PAT secret is set in GitHub Secrets (Production environment)"
            fi

            # Pull the image
            if docker pull "${IMAGE_FULL_NAME}"; then
              echo "‚úÖ Image pulled successfully"
            else
              echo "‚ùå Failed to pull image. Please ensure:"
              echo "   1. GHCR_PAT secret is set in GitHub Secrets (Production environment)"
              echo "   2. The package permissions allow the token to read"
              echo "   3. The image exists in GHCR: ${IMAGE_FULL_NAME}"
              exit 1
            fi

            # Tag it for local use (docker-compose expects hrms-frontend:latest)
            docker tag "${IMAGE_FULL_NAME}" "${IMAGE_NAME}:latest"
            echo "‚úÖ Docker image pulled and tagged as ${IMAGE_NAME}:latest"
            docker images | grep "${IMAGE_NAME}" || true

      - name: Create/Update .env file on server
        uses: appleboy/ssh-action@v1.0.0
        env:
          DB_ROOT_PASSWORD: ${{ secrets.DB_ROOT_PASSWORD }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_PORT: ${{ secrets.DB_PORT || '3306' }}
          DB_DIALECT: ${{ secrets.DB_DIALECT || 'mysql' }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
          EMAIL_FROM: ${{ secrets.EMAIL_FROM || 'no-reply@kitor.io' }}
          EMAIL_FROM_NAME: ${{ secrets.EMAIL_FROM_NAME || 'Xylobit HRMS' }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          DOMAIN: ${{ secrets.DOMAIN }}
          BACKEND_URL: ${{ secrets.BACKEND_URL }}
          REACT_APP_BACKEND_URL: ${{ secrets.REACT_APP_BACKEND_URL }}
          REACT_APP_FRONTEND_URL: ${{ secrets.REACT_APP_FRONTEND_URL }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_S3_BUCKET_NAME: ${{ secrets.AWS_S3_BUCKET_NAME }}
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory (with fallbacks)
            BASE_DIR="/opt/hrms"
            if [ ! -d "$BASE_DIR" ]; then
              BASE_DIR="$HOME/hrms"
              if [ ! -d "$BASE_DIR" ]; then
                BASE_DIR="/tmp/hrms"
              fi
              mkdir -p "$BASE_DIR" || {
                echo "‚ùå Failed to create directory. Trying with sudo..."
                sudo mkdir -p /opt/hrms || mkdir -p ~/hrms || mkdir -p /tmp/hrms
                BASE_DIR="/opt/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="$HOME/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="/tmp/hrms"
              }
            fi
            mkdir -p "$BASE_DIR/frontend" || sudo mkdir -p "$BASE_DIR/frontend" || mkdir -p "$HOME/hrms/frontend" || mkdir -p "/tmp/hrms/frontend"
            cd "$BASE_DIR" || exit 1

            # Create .env file from GitHub Secrets (automated)
            {
              echo "# =========================================="
              echo "# HRMS Application Environment Variables"
              echo "# Auto-generated from GitHub Secrets"
              echo "# =========================================="
              echo ""
              echo "# Application Configuration"
              echo "NODE_ENV=production"
              echo ""
              echo "# Database Configuration"
              echo "DB_ROOT_PASSWORD=${DB_ROOT_PASSWORD}"
              echo "DB_NAME=${DB_NAME}"
              echo "DB_USER=${DB_USER}"
              echo "DB_PASSWORD=${DB_PASSWORD}"
              echo "DB_PORT=${DB_PORT}"
              echo "DB_DIALECT=${DB_DIALECT}"
              echo ""
              echo "# Security & Authentication"
              echo "JWT_SECRET=${JWT_SECRET}"
              echo ""
              echo "# Email Configuration (SendGrid)"
              echo "SENDGRID_API_KEY=${SENDGRID_API_KEY}"
              echo "EMAIL_FROM=${EMAIL_FROM}"
              echo "EMAIL_FROM_NAME=${EMAIL_FROM_NAME}"
              echo ""
              echo "# URL Configuration"
              echo "FRONTEND_URL=${FRONTEND_URL}"
              echo "DOMAIN=${DOMAIN}"
              echo "BACKEND_URL=${BACKEND_URL}"
              echo ""
              echo "# Frontend Environment Variables (React - for docker-compose)"
              echo "REACT_APP_BACKEND_URL=${REACT_APP_BACKEND_URL}"
              echo "REACT_APP_FRONTEND_URL=${REACT_APP_FRONTEND_URL}"
              echo ""
              echo "# AWS S3 Configuration (File Storage)"
              echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}"
              echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}"
              echo "AWS_REGION=${AWS_REGION}"
              echo "AWS_S3_BUCKET_NAME=${AWS_S3_BUCKET_NAME}"
            } > "$BASE_DIR/frontend/.env"

            # Set secure permissions
            chmod 600 "$BASE_DIR/frontend/.env"
            echo ".env file created/updated successfully from GitHub Secrets at $BASE_DIR/frontend/.env"

      - name: Encode frontend docker-compose file
        id: encode_frontend_compose
        run: |
          FRONTEND_COMPOSE_B64=$(base64 -w 0 frontend/docker-compose.yml)
          echo "frontend_compose_b64=$FRONTEND_COMPOSE_B64" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend docker-compose.yml encoded"

      - name: Write frontend docker-compose.yml to server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory
            BASE_DIR="/opt/hrms"
            if [ ! -d "$BASE_DIR" ]; then
              BASE_DIR="$HOME/hrms"
              if [ ! -d "$BASE_DIR" ]; then
                BASE_DIR="/tmp/hrms"
              fi
            fi
            mkdir -p "$BASE_DIR/frontend" || sudo mkdir -p "$BASE_DIR/frontend" || mkdir -p "$HOME/hrms/frontend" || mkdir -p "/tmp/hrms/frontend"

            # Decode and write docker-compose.yml
            echo "${{ steps.encode_frontend_compose.outputs.frontend_compose_b64 }}" | base64 -d > $BASE_DIR/frontend/docker-compose.yml

            # Set permissions
            chmod 644 $BASE_DIR/frontend/docker-compose.yml 2>/dev/null || sudo chmod 644 $BASE_DIR/frontend/docker-compose.yml || true

            # Verify file
            echo "‚úÖ Frontend docker-compose.yml written to: $BASE_DIR/frontend/"
            ls -la $BASE_DIR/frontend/docker-compose.yml || ls -la ~/hrms/frontend/docker-compose.yml || ls -la /tmp/hrms/frontend/docker-compose.yml

      - name: Deploy to Digital Ocean Droplet
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory (with fallbacks)
            BASE_DIR="/opt/hrms"
            if [ ! -d "$BASE_DIR" ]; then
              BASE_DIR="$HOME/hrms"
              if [ ! -d "$BASE_DIR" ]; then
                BASE_DIR="/tmp/hrms"
              fi
              mkdir -p "$BASE_DIR" || {
                echo "‚ùå Failed to create directory. Trying with sudo..."
                sudo mkdir -p /opt/hrms || mkdir -p ~/hrms || mkdir -p /tmp/hrms
                BASE_DIR="/opt/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="$HOME/hrms"
                [ ! -d "$BASE_DIR" ] && BASE_DIR="/tmp/hrms"
              }
            fi
            cd "$BASE_DIR" || exit 1

            # Check which docker compose command is available
            DOCKER_COMPOSE_CMD=""
            # Test docker-compose (standalone)
            if command -v docker-compose >/dev/null 2>&1; then
              if docker-compose --version >/dev/null 2>&1; then
                DOCKER_COMPOSE_CMD="docker-compose"
                echo "‚úÖ Found docker-compose (standalone)"
              fi
            fi
            # Test docker compose (plugin) if standalone not found
            if [ -z "$DOCKER_COMPOSE_CMD" ]; then
              if docker compose version >/dev/null 2>&1; then
                DOCKER_COMPOSE_CMD="docker compose"
                echo "‚úÖ Found docker compose (plugin)"
              fi
            fi
            # Error if neither is found
            if [ -z "$DOCKER_COMPOSE_CMD" ]; then
              echo "‚ùå Error: Neither 'docker-compose' nor 'docker compose' is available."
              echo "Please install Docker Compose:"
              echo "  For plugin version (recommended):"
              echo "    sudo apt-get update && sudo apt-get install docker-compose-plugin"
              echo "  Or for standalone version:"
              echo "    sudo apt-get update && sudo apt-get install docker-compose"
              exit 1
            fi

            # Create shared network if it doesn't exist
            docker network create hrms-network --driver bridge 2>/dev/null || true

            # Ensure frontend directory and docker-compose.yml exist
            if [ ! -d "frontend" ]; then
              mkdir -p frontend
              echo "‚ö†Ô∏è  Frontend directory not found, creating it..."
            fi
            if [ ! -f "frontend/docker-compose.yml" ]; then
              echo "‚ùå Error: frontend/docker-compose.yml not found at $BASE_DIR/frontend/"
              echo "Please ensure the docker-compose.yml file is present in the frontend directory."
              exit 1
            fi

            # Start frontend service
            cd frontend

            # Export environment variables for docker-compose (from .env file)
            set -a
            source "$BASE_DIR/frontend/.env"
            set +a

            # Use the pulled image (already tagged as hrms-frontend:latest)
            $DOCKER_COMPOSE_CMD up -d --no-deps frontend

            # Clean up unused Docker resources
            echo "üßπ Cleaning up unused Docker resources..."

            # Show disk usage before cleanup
            echo "üìä Disk usage before cleanup:"
            docker system df

            # Remove stopped containers
            echo "üóëÔ∏è  Removing stopped containers..."
            docker container prune -f

            # Remove unused images (but keep images that are in use)
            echo "üóëÔ∏è  Removing unused images..."
            docker image prune -af --filter "until=24h" || docker image prune -af

            # Remove unused volumes (but keep named volumes)
            echo "üóëÔ∏è  Removing unused volumes..."
            docker volume prune -f

            # Remove unused networks (but keep hrms-network)
            echo "üóëÔ∏è  Removing unused networks..."
            docker network prune -f

            # Show disk usage after cleanup
            echo "üìä Disk usage after cleanup:"
            docker system df

            echo "‚úÖ Docker cleanup completed"

      - name: Create parent directories on server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Create directories with sudo if needed, or check if they exist
            if [ ! -d "/opt/hrms" ]; then
              sudo mkdir -p /opt/hrms || mkdir -p ~/hrms || mkdir -p /tmp/hrms
            fi
            mkdir -p /opt/hrms/nginx 2>/dev/null || sudo mkdir -p /opt/hrms/nginx || mkdir -p ~/hrms/nginx || mkdir -p /tmp/hrms/nginx
            sudo chmod -R 755 /opt/hrms 2>/dev/null || chmod -R 755 ~/hrms 2>/dev/null || chmod -R 755 /tmp/hrms 2>/dev/null || true
            echo "‚úÖ Directories created"

      - name: Encode nginx files to base64
        id: encode_files
        run: |
          DOCKER_COMPOSE_B64=$(base64 -w 0 nginx/docker-compose.yml)
          NGINX_CONF_B64=$(base64 -w 0 nginx/nginx.conf)
          NGINX_INITIAL_B64=$(base64 -w 0 nginx/nginx.conf.initial)
          echo "docker_compose_b64=$DOCKER_COMPOSE_B64" >> $GITHUB_OUTPUT
          echo "nginx_conf_b64=$NGINX_CONF_B64" >> $GITHUB_OUTPUT
          echo "nginx_initial_b64=$NGINX_INITIAL_B64" >> $GITHUB_OUTPUT
          echo "‚úÖ Files encoded"

      - name: Write nginx files to server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            # Determine the base directory (with fallbacks and proper permissions)
            BASE_DIR="/opt/hrms"
            if [ ! -d "$BASE_DIR" ]; then
              if sudo mkdir -p "$BASE_DIR" 2>/dev/null; then
                sudo chown -R $USER:$USER "$BASE_DIR" 2>/dev/null || sudo chmod -R 755 "$BASE_DIR" 2>/dev/null || true
                echo "‚úÖ Created $BASE_DIR with sudo"
              else
                BASE_DIR="$HOME/hrms"
                if [ ! -d "$BASE_DIR" ]; then
                  mkdir -p "$BASE_DIR" || BASE_DIR="/tmp/hrms"
                fi
                echo "‚ö†Ô∏è  Using fallback directory: $BASE_DIR"
              fi
            fi

            # Ensure nginx directory exists
            mkdir -p "$BASE_DIR/nginx" || sudo mkdir -p "$BASE_DIR/nginx" || {
              echo "‚ùå Failed to create nginx directory"
              exit 1
            }

            # Decode and write files
            echo "${{ steps.encode_files.outputs.docker_compose_b64 }}" | base64 -d > "$BASE_DIR/nginx/docker-compose.yml"
            echo "${{ steps.encode_files.outputs.nginx_conf_b64 }}" | base64 -d > "$BASE_DIR/nginx/nginx.conf"
            echo "${{ steps.encode_files.outputs.nginx_initial_b64 }}" | base64 -d > "$BASE_DIR/nginx/nginx.conf.initial"

            # Create backup of SSL-enabled config (nginx.conf contains SSL config)
            cp "$BASE_DIR/nginx/nginx.conf" "$BASE_DIR/nginx/nginx.conf.backup" 2>/dev/null || true

            # Set permissions
            chmod 644 "$BASE_DIR/nginx"/*.yml "$BASE_DIR/nginx"/*.conf 2>/dev/null || sudo chmod 644 "$BASE_DIR/nginx"/*.yml "$BASE_DIR/nginx"/*.conf || true

            # Verify files
            echo "Files written to: $BASE_DIR/nginx/"
            ls -la "$BASE_DIR/nginx/" || ls -la ~/hrms/nginx/ || ls -la /tmp/hrms/nginx/
            echo "‚úÖ All nginx files copied successfully"

      - name: Deploy Nginx Reverse Proxy
        uses: appleboy/ssh-action@v1.0.0
        timeout-minutes: 10
        env:
          DOMAIN: ${{ secrets.DOMAIN || 'h-rms.me' }}
          SSL_EMAIL: ${{ secrets.EMAIL_FROM || 'admin@h-rms.me' }}
        with:
          host: ${{ secrets.DO_HOST }}
          username: ${{ secrets.DO_USERNAME }}
          key: ${{ secrets.DO_SSH_KEY }}
          port: ${{ secrets.DO_PORT || 22 }}
          script: |
            echo "üîß Setting up Nginx reverse proxy..."

            # Detect which docker-compose command is available
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose >/dev/null 2>&1; then
              if docker-compose --version >/dev/null 2>&1; then
                DOCKER_COMPOSE_CMD="docker-compose"
                echo "‚úÖ Found docker-compose (standalone)"
              fi
            elif docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
              echo "‚úÖ Found docker compose (plugin)"
            else
              echo "‚ùå Error: Neither 'docker-compose' nor 'docker compose' is available."
              echo "Please install docker-compose on the server:"
              echo "   For Docker Compose v2 (plugin):"
              echo "    sudo apt-get update && sudo apt-get install docker-compose-plugin"
              echo "   For Docker Compose v1 (standalone):"
              echo "    sudo apt-get update && sudo apt-get install docker-compose"
              exit 1
            fi

            # Determine the base directory (with fallbacks and proper permissions)
            BASE_DIR="/opt/hrms"
            if [ ! -d "$BASE_DIR" ]; then
              if sudo mkdir -p "$BASE_DIR" 2>/dev/null; then
                sudo chown -R $USER:$USER "$BASE_DIR" 2>/dev/null || sudo chmod -R 755 "$BASE_DIR" 2>/dev/null || true
                echo "‚úÖ Created $BASE_DIR with sudo"
              else
                BASE_DIR="$HOME/hrms"
                if [ ! -d "$BASE_DIR" ]; then
                  mkdir -p "$BASE_DIR" || BASE_DIR="/tmp/hrms"
                fi
                echo "‚ö†Ô∏è  Using fallback directory: $BASE_DIR"
              fi
            fi

            # Ensure nginx directory exists
            mkdir -p "$BASE_DIR/nginx" || sudo mkdir -p "$BASE_DIR/nginx" || {
              echo "‚ùå Failed to create nginx directory"
              exit 1
            }
            cd "$BASE_DIR/nginx" || exit 1

            # Update container ports to bind to localhost (if not already done)
            if [ -d "$BASE_DIR/backend" ] && [ -f "$BASE_DIR/backend/docker-compose.yml" ]; then
              cd "$BASE_DIR/backend"
              if grep -q '"8000:8000"' docker-compose.yml 2>/dev/null; then
                sed -i 's/"8000:8000"/"127.0.0.1:8000:8000"/' docker-compose.yml
                $DOCKER_COMPOSE_CMD restart backend || true
                echo "‚úÖ Backend ports updated to localhost"
              fi
            fi

            if [ -d "$BASE_DIR/frontend" ] && [ -f "$BASE_DIR/frontend/docker-compose.yml" ]; then
              cd "$BASE_DIR/frontend"
              if grep -q '"80:80"' docker-compose.yml 2>/dev/null; then
                sed -i 's/"80:80"/"127.0.0.1:80:80"/' docker-compose.yml
                $DOCKER_COMPOSE_CMD restart frontend || true
                echo "‚úÖ Frontend ports updated to localhost"
              fi
            fi

            # Return to nginx directory
            cd "$BASE_DIR/nginx" || exit 1

            # Copy nginx files if they don't exist (from repo)
            if [ ! -f "docker-compose.yml" ]; then
              echo "‚ö†Ô∏è  Nginx files not found. Please ensure nginx/ directory exists in repo."
              echo "   For now, skipping nginx deployment."
              exit 0
            fi

            # Create certbot directories
            mkdir -p certbot/conf certbot/www

            # Ensure network exists
            docker network create hrms-network --driver bridge 2>/dev/null || true

            # Get domain and email from environment (passed via secrets)
            DOMAIN="${DOMAIN:-h-rms.me}"
            SSL_EMAIL="${SSL_EMAIL:-admin@${DOMAIN}}"

            echo "üìç Working directory: $(pwd)"
            echo "üåê Domain: ${DOMAIN}"
            echo "üìß SSL Email: ${SSL_EMAIL}"

            # Backup the original nginx.conf from repo (contains SSL config)
            if [ -f "nginx.conf" ] && [ ! -f "nginx.conf.backup" ]; then
              cp nginx.conf nginx.conf.backup
              echo "‚úÖ Backed up original nginx.conf"
            fi

            # Check if SSL certificates exist
            if [ -f "certbot/conf/live/${DOMAIN}/fullchain.pem" ]; then
              echo "‚úÖ SSL certificates found for ${DOMAIN}, using SSL config"
              # Ensure we have the full nginx.conf with SSL
              if [ ! -f "nginx.conf" ] || ! grep -q "ssl_certificate" nginx.conf 2>/dev/null; then
                echo "üîÑ Restoring SSL-enabled nginx.conf..."
                if [ -f "nginx.conf.backup" ]; then
                  cp nginx.conf.backup nginx.conf
                  # Update domain in config if different
                  sed -i "s/h-rms.me/${DOMAIN}/g" nginx.conf 2>/dev/null || true
                fi
              else
                # Update domain in existing SSL config if needed
                if ! grep -q "server_name ${DOMAIN}" nginx.conf 2>/dev/null; then
                  echo "üîÑ Updating domain in nginx.conf to ${DOMAIN}..."
                  sed -i "s/h-rms.me/${DOMAIN}/g" nginx.conf 2>/dev/null || true
                fi
              fi
            else
              echo "‚ö†Ô∏è  SSL certificates not found for ${DOMAIN}"
              echo "üìù Starting with HTTP-only config, will attempt SSL setup..."
              
              # Use initial HTTP-only config first
              if [ -f "nginx.conf.initial" ]; then
                cp nginx.conf.initial nginx.conf
                # Update domain in initial config
                sed -i "s/h-rms.me/${DOMAIN}/g" nginx.conf 2>/dev/null || true
              fi

              # Start nginx with HTTP-only config first (required for certbot validation)
              echo "üöÄ Starting Nginx with HTTP-only config..."
              $DOCKER_COMPOSE_CMD up -d nginx
              
              # Wait for nginx to be ready
              sleep 5
              if ! docker ps | grep -q hrms-nginx; then
                echo "‚ùå Failed to start nginx. Check logs:"
                docker logs hrms-nginx || true
                exit 1
              fi
              
              # Ensure webroot directory is accessible
              echo "üîç Verifying webroot directory setup..."
              mkdir -p certbot/www/.well-known/acme-challenge
              chmod -R 755 certbot/www 2>/dev/null || true
              
              # Test if nginx can serve the webroot
              TEST_FILE="certbot/www/.well-known/acme-challenge/test-$$"
              echo "test" > "$TEST_FILE"
              HTTP_TEST=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "http://${DOMAIN}/.well-known/acme-challenge/test-$$" || echo "000")
              rm -f "$TEST_FILE" 2>/dev/null || true
              
              if [ "$HTTP_TEST" = "200" ] || [ "$HTTP_TEST" = "404" ]; then
                echo "   ‚úÖ Webroot directory is accessible via nginx"
              else
                echo "   ‚ö†Ô∏è  Webroot may not be accessible (HTTP status: ${HTTP_TEST})"
                echo "   This might prevent certbot validation"
              fi
              
              echo "‚úÖ Nginx is running, attempting SSL certificate setup..."
              
              # First, verify DNS is pointing to this server
              echo "üîç Verifying DNS configuration..."
              SERVER_IP=$(curl -s ifconfig.me || curl -s ipinfo.io/ip || curl -s icanhazip.com || echo "unknown")
              DOMAIN_IP=$(dig +short ${DOMAIN} | tail -n1 || nslookup ${DOMAIN} 2>/dev/null | grep -A1 "Name:" | tail -n1 | awk '{print $2}' || echo "unknown")
              
              echo "   Server IP: ${SERVER_IP}"
              echo "   Domain ${DOMAIN} resolves to: ${DOMAIN_IP}"
              
              if [ "$DOMAIN_IP" != "unknown" ] && [ "$SERVER_IP" != "unknown" ] && [ "$DOMAIN_IP" = "$SERVER_IP" ]; then
                echo "   ‚úÖ DNS is correctly pointing to this server"
              else
                echo "   ‚ö†Ô∏è  DNS may not be fully propagated or not pointing to this server"
                echo "   Server IP: ${SERVER_IP}"
                echo "   Domain IP: ${DOMAIN_IP}"
                echo "   Continuing with SSL attempt anyway (DNS may still be propagating)..."
              fi
              
              # Test if domain is accessible via HTTP
              echo "üîç Testing HTTP accessibility..."
              HTTP_TEST=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 http://${DOMAIN} || echo "000")
              if [ "$HTTP_TEST" = "200" ] || [ "$HTTP_TEST" = "301" ] || [ "$HTTP_TEST" = "302" ]; then
                echo "   ‚úÖ Domain is accessible via HTTP (status: ${HTTP_TEST})"
              else
                echo "   ‚ö†Ô∏è  Domain may not be accessible via HTTP (status: ${HTTP_TEST})"
                echo "   This could be due to DNS propagation delay or firewall issues"
              fi
              
              # Attempt to obtain SSL certificates with timeout
              echo "üîê Requesting SSL certificates from Let's Encrypt for ${DOMAIN}..."
              echo "   This may take 1-3 minutes. Please be patient..."
              
              # Run certbot with timeout (5 minutes to allow for DNS propagation checks)
              # Use timeout command if available, otherwise rely on SSH action timeout
              if command -v timeout >/dev/null 2>&1; then
                CERTBOT_TIMEOUT=300
                echo "   Using timeout command (${CERTBOT_TIMEOUT}s)..."
                CERTBOT_OUTPUT=$(timeout ${CERTBOT_TIMEOUT} $DOCKER_COMPOSE_CMD run --rm certbot certonly \
                  --webroot \
                  --webroot-path=/var/www/certbot \
                  --email "${SSL_EMAIL}" \
                  --agree-tos \
                  --no-eff-email \
                  --non-interactive \
                  --verbose \
                  -d "${DOMAIN}" \
                  -d "www.${DOMAIN}" \
                  -d "api.${DOMAIN}" 2>&1) || CERTBOT_EXIT=$?
              else
                echo "   timeout command not available, running certbot directly..."
                CERTBOT_OUTPUT=$($DOCKER_COMPOSE_CMD run --rm certbot certonly \
                  --webroot \
                  --webroot-path=/var/www/certbot \
                  --email "${SSL_EMAIL}" \
                  --agree-tos \
                  --no-eff-email \
                  --non-interactive \
                  --verbose \
                  -d "${DOMAIN}" \
                  -d "www.${DOMAIN}" \
                  -d "api.${DOMAIN}" 2>&1) || CERTBOT_EXIT=$?
              fi
              
              echo "--- Certbot Output ---"
              echo "$CERTBOT_OUTPUT"
              echo "--- End Certbot Output ---"
              
              if [ -z "$CERTBOT_EXIT" ] || [ "$CERTBOT_EXIT" -eq 0 ]; then
                echo "‚úÖ Certbot command executed successfully"
              else
                if [ "$CERTBOT_EXIT" -eq 124 ]; then
                  echo "‚ö†Ô∏è  SSL certificate setup timed out after ${CERTBOT_TIMEOUT}s"
                  echo "   Possible reasons:"
                  echo "   1. DNS propagation is still in progress (can take up to 48 hours)"
                  echo "   2. Domain is not accessible from the internet"
                  echo "   3. Port 80 is blocked by firewall"
                  echo "   4. Let's Encrypt servers cannot reach your domain"
                else
                  echo "‚ö†Ô∏è  SSL certificate setup failed (exit code: $CERTBOT_EXIT)"
                  echo "   Check the certbot output above for details"
                  echo "   Common issues:"
                  echo "   1. DNS not fully propagated yet"
                  echo "   2. Domain not accessible from internet"
                  echo "   3. Port 80 blocked by firewall"
                  echo "   4. Let's Encrypt rate limits (too many requests)"
                  echo "   5. Invalid domain or email address"
                fi
                echo "   Continuing with HTTP-only configuration..."
                echo "   You can manually set up SSL later by running:"
                echo "   cd $BASE_DIR/nginx && $DOCKER_COMPOSE_CMD run --rm certbot certonly --webroot --webroot-path=/var/www/certbot -d ${DOMAIN} -d www.${DOMAIN} -d api.${DOMAIN}"
              fi
              
              # Check if certificates were successfully created
              if [ -f "certbot/conf/live/${DOMAIN}/fullchain.pem" ]; then
                echo "‚úÖ SSL certificates obtained successfully!"
                echo "üîÑ Switching to HTTPS configuration..."
                
                # Restore SSL-enabled nginx.conf
                if [ -f "nginx.conf.backup" ]; then
                  cp nginx.conf.backup nginx.conf
                  # Update domain in config
                  sed -i "s/h-rms.me/${DOMAIN}/g" nginx.conf 2>/dev/null || true
                  # Update certificate paths to match domain
                  sed -i "s|/etc/letsencrypt/live/h-rms.me|/etc/letsencrypt/live/${DOMAIN}|g" nginx.conf 2>/dev/null || true
                else
                  echo "‚ö†Ô∏è  Full SSL config not found, certificates obtained but config may need manual update"
                fi
                
                # Test and reload nginx to apply SSL config
                echo "üîÑ Testing and reloading nginx with SSL configuration..."
                if docker exec hrms-nginx nginx -t 2>/dev/null; then
                  docker exec hrms-nginx nginx -s reload
                  echo "‚úÖ Nginx reloaded with SSL configuration"
                else
                  echo "‚ö†Ô∏è  Nginx config test failed, but certificates are available"
                  echo "   You may need to manually fix the nginx.conf file"
                fi
              else
                echo "‚ö†Ô∏è  SSL certificates not obtained, continuing with HTTP-only configuration"
                echo "   The site will be accessible via HTTP only"
              fi
            fi

            # Final verification and SSL status check
            echo "üîç Final verification..."
            if docker ps | grep -q hrms-nginx; then
              echo "‚úÖ Nginx reverse proxy is running"
              
              # Check SSL certificate status
              echo "üìã SSL Certificate Status:"
              if [ -f "certbot/conf/live/${DOMAIN}/fullchain.pem" ]; then
                echo "  ‚úÖ SSL certificates exist for ${DOMAIN}"
                ls -lh certbot/conf/live/${DOMAIN}/ 2>/dev/null || true
              else
                echo "  ‚ùå SSL certificates NOT found for ${DOMAIN}"
                echo "  üìç Expected path: certbot/conf/live/${DOMAIN}/fullchain.pem"
                echo "  üí° To enable HTTPS, ensure:"
                echo "     1. Domain DNS points to this server"
                echo "     2. Port 80 is accessible from internet"
                echo "     3. Run the workflow again after DNS is configured"
              fi
              
              # Check nginx config
              if docker exec hrms-nginx nginx -t 2>/dev/null; then
                echo "‚úÖ Nginx config is valid"
                
                # Check if SSL is configured in nginx
                if docker exec hrms-nginx cat /etc/nginx/conf.d/default.conf 2>/dev/null | grep -q "ssl_certificate"; then
                  echo "‚úÖ HTTPS is configured in nginx.conf"
                  
                  # Verify SSL is actually working
                  echo "üîç Testing HTTPS configuration..."
                  if docker exec hrms-nginx cat /etc/nginx/conf.d/default.conf 2>/dev/null | grep -q "listen 443"; then
                    echo "‚úÖ Nginx is listening on port 443 (HTTPS)"
                  else
                    echo "‚ö†Ô∏è  Nginx config has SSL but no listen 443 directive"
                  fi
                  
                  # Check if certificates are accessible in container
                  if docker exec hrms-nginx test -f /etc/letsencrypt/live/${DOMAIN}/fullchain.pem 2>/dev/null; then
                    echo "‚úÖ SSL certificates are accessible in nginx container"
                  else
                    echo "‚ö†Ô∏è  SSL certificates not found in nginx container"
                    echo "   Certificates exist on host but may not be mounted correctly"
                    echo "   Restarting nginx container to remount volumes..."
                    $DOCKER_COMPOSE_CMD restart nginx
                    sleep 3
                  fi
                else
                  echo "‚ÑπÔ∏è  Running in HTTP-only mode"
                  echo "   Current nginx.conf does not have SSL configuration"
                  
                  # If certificates exist but config doesn't have SSL, fix it
                  if [ -f "certbot/conf/live/${DOMAIN}/fullchain.pem" ]; then
                    echo "üîÑ SSL certificates exist but nginx.conf doesn't use them!"
                    echo "   Updating nginx.conf to use SSL..."
                    if [ -f "nginx.conf.backup" ]; then
                      cp nginx.conf.backup nginx.conf
                      sed -i "s/h-rms.me/${DOMAIN}/g" nginx.conf 2>/dev/null || true
                      sed -i "s|/etc/letsencrypt/live/h-rms.me|/etc/letsencrypt/live/${DOMAIN}|g" nginx.conf 2>/dev/null || true
                      $DOCKER_COMPOSE_CMD restart nginx
                      sleep 3
                      echo "‚úÖ Nginx restarted with SSL configuration"
                    fi
                  fi
                fi
              else
                echo "‚ö†Ô∏è  Nginx config test failed. Check logs:"
                docker logs hrms-nginx || true
              fi
            else
              echo "‚ùå Nginx container is not running. Check logs:"
              docker logs hrms-nginx || true
              exit 1
            fi

      # - name: Health Check
      #   run: |
      #     sleep 10
      #     curl -f ${{ secrets.FRONTEND_DEPLOY_URL }}/health || exit 1
